{"version":3,"sources":["../src/index.ts","../src/lib/BaseLinkPlugin.ts","../src/lib/utils/getLinkAttributes.ts","../src/lib/utils/createLinkNode.ts","../src/lib/utils/encodeUrlIfNeeded.ts","../src/lib/utils/safeDecodeUrl.ts","../src/lib/utils/validateUrl.ts","../src/lib/withLink.ts","../src/lib/transforms/insertLink.ts","../src/lib/transforms/unwrapLink.ts","../src/lib/transforms/upsertLink.ts","../src/lib/transforms/upsertLinkText.ts","../src/lib/transforms/wrapLink.ts"],"sourcesContent":["/**\n * @file Automatically generated by barrelsby.\n */\n\nexport * from './lib/index';\n","import {\n  type EditorBeforeOptions,\n  type PluginConfig,\n  createTSlatePlugin,\n  getEditorPlugin,\n  isUrl,\n} from '@udecode/plate';\nimport {\n  RemoveEmptyNodesPlugin,\n  withRemoveEmptyNodes,\n} from '@udecode/plate-normalizers';\n\nimport type { TLinkElement } from './types';\n\nimport { getLinkAttributes } from './utils/getLinkAttributes';\nimport { validateUrl } from './utils/index';\nimport { withLink } from './withLink';\n\nexport type BaseLinkConfig = PluginConfig<\n  'a',\n  {\n    /**\n     * List of allowed URL schemes.\n     *\n     * @default ['http', 'https', 'mailto', 'tel']\n     */\n    allowedSchemes?: string[];\n    /**\n     * Skips sanitation of links.\n     *\n     * @default false\n     */\n    dangerouslySkipSanitization?: boolean;\n    defaultLinkAttributes?: React.AnchorHTMLAttributes<HTMLAnchorElement>;\n    forceSubmit?: boolean;\n    /**\n     * Keeps selected text on pasting links by default.\n     *\n     * @default true\n     */\n    keepSelectedTextOnPaste?: boolean;\n    /**\n     * Allow custom config for rangeBeforeOptions.\n     *\n     * @example\n     *   {\n     *     \"matchString\": \" \",\n     *     \"skipInvalid\": true,\n     *     \"afterMatch\": true\n     *   }\n     */\n    rangeBeforeOptions?: EditorBeforeOptions;\n    /**\n     * Hotkeys to trigger floating link.\n     *\n     * @default 'meta+k, ctrl+k'\n     */\n    triggerFloatingLinkHotkeys?: string[] | string;\n    /**\n     * On keyboard shortcut or toolbar mousedown, get the link url by calling\n     * this promise. The default behavior is to use the browser's native\n     * `prompt`.\n     */\n    getLinkUrl?: (prevUrl: string | null) => Promise<string | null>;\n    /**\n     * Callback to optionally get the href for a url\n     *\n     * @returns Href: an optional link to be used that is different from the\n     *   text content (example https://google.com for google.com)\n     */\n    getUrlHref?: (url: string) => string | undefined;\n    /**\n     * Callback to validate an url.\n     *\n     * @default isUrl\n     */\n    isUrl?: (text: string) => boolean;\n    /**\n     * Transform the content of the URL input before validating it. Useful for\n     * adding a protocol to a URL. E.g. `google.com` -> `https://google.com`\n     *\n     * Similar to `getUrlHref` but is used on URL inputs. Whereas that is used\n     * on any entered text.\n     *\n     * @returns The transformed URL.\n     */\n    transformInput?: (url: string) => string | undefined;\n  }\n>;\n\n/** Enables support for hyperlinks. */\nexport const BaseLinkPlugin = createTSlatePlugin<BaseLinkConfig>({\n  key: 'a',\n  node: {\n    dangerouslyAllowAttributes: ['target'],\n    isElement: true,\n    isInline: true,\n    props: ({ editor, element }) =>\n      getLinkAttributes(editor, element as TLinkElement),\n  },\n  options: {\n    allowedSchemes: ['http', 'https', 'mailto', 'tel'],\n    dangerouslySkipSanitization: false,\n    defaultLinkAttributes: {},\n    isUrl,\n    keepSelectedTextOnPaste: true,\n    rangeBeforeOptions: {\n      afterMatch: true,\n      matchBlockStart: true,\n      matchString: ' ',\n      skipInvalid: true,\n    },\n  },\n  parsers: {\n    html: {\n      deserializer: {\n        rules: [\n          {\n            validNodeName: 'A',\n          },\n        ],\n        parse: ({ editor, element, type }) => {\n          const url = element.getAttribute('href');\n\n          if (url && validateUrl(editor, url)) {\n            return {\n              target: element.getAttribute('target') || '_blank',\n              type,\n              url,\n            };\n          }\n        },\n      },\n    },\n  },\n})\n  .overrideEditor(withLink)\n  .overrideEditor(\n    ({ editor, type }) =>\n      withRemoveEmptyNodes(\n        getEditorPlugin(\n          editor,\n          RemoveEmptyNodesPlugin.configure({\n            options: { types: type },\n          })\n        )\n      ) as any\n  );\n","import { type SlateEditor, sanitizeUrl } from '@udecode/plate';\n\nimport type { TLinkElement } from '../../lib/types';\nimport type { BaseLinkConfig } from '../BaseLinkPlugin';\n\nexport const getLinkAttributes = (editor: SlateEditor, link: TLinkElement) => {\n  const { allowedSchemes, dangerouslySkipSanitization, defaultLinkAttributes } =\n    editor.getOptions<BaseLinkConfig>({ key: 'a' });\n\n  const attributes = { ...defaultLinkAttributes };\n\n  const href = dangerouslySkipSanitization\n    ? link.url\n    : sanitizeUrl(link.url, { allowedSchemes }) || undefined;\n\n  // Avoid passing `undefined` for href or target\n  if (href !== undefined) {\n    attributes.href = href;\n  }\n  if ('target' in link && link.target !== undefined) {\n    attributes.target = link.target;\n  }\n\n  return attributes;\n};\n","import type { SlateEditor, TText } from '@udecode/plate';\n\nimport type { TLinkElement } from '../types';\n\nimport { BaseLinkPlugin } from '../BaseLinkPlugin';\n\nexport interface CreateLinkNodeOptions {\n  url: string;\n  children?: TText[];\n  target?: string;\n  text?: string;\n}\n\nexport const createLinkNode = (\n  editor: SlateEditor,\n  { children, target, text = '', url }: CreateLinkNodeOptions\n): TLinkElement => {\n  const type = editor.getType(BaseLinkPlugin);\n\n  return {\n    children: children ?? [{ text }],\n    target,\n    type,\n    url,\n  };\n};\n","/**\n * If a URL has not already been encoded and contains characters that require\n * encoding, encode the URL.\n *\n * @param url URL to encode\n */\nexport const encodeUrlIfNeeded = (url: string) => {\n  try {\n    const isEncoded = url !== decodeURIComponent(url);\n\n    return isEncoded ? url : encodeURI(url);\n  } catch (error) {\n    if (error instanceof URIError) {\n      return url;\n    }\n\n    throw error;\n  }\n};\n","export const safeDecodeUrl = (url: string) => {\n  try {\n    return decodeURI(url);\n  } catch (error) {\n    if (error instanceof URIError) {\n      return url;\n    }\n\n    throw error;\n  }\n};\n","import { type SlateEditor, sanitizeUrl } from '@udecode/plate';\n\nimport { BaseLinkPlugin } from '../BaseLinkPlugin';\n\nexport const validateUrl = (editor: SlateEditor, url: string): boolean => {\n  const { allowedSchemes, dangerouslySkipSanitization, isUrl } =\n    editor.getOptions(BaseLinkPlugin);\n\n  // Allow internal links starting with / or #\n  if (url.startsWith('/') || url.startsWith('#')) {\n    return true;\n  }\n\n  if (isUrl && !isUrl(url)) return false;\n  if (\n    !dangerouslySkipSanitization &&\n    !sanitizeUrl(url, {\n      allowedSchemes,\n      permitInvalid: true,\n    })\n  )\n    return false;\n\n  return true;\n};\n","import {\n  type OverrideEditor,\n  type Point,\n  type TRange,\n  PathApi,\n  RangeApi,\n} from '@udecode/plate';\n\nimport type { BaseLinkConfig } from './BaseLinkPlugin';\n\nimport { upsertLink } from './transforms/index';\n\n/**\n * Insert space after a url to wrap a link. Lookup from the block start to the\n * cursor to check if there is an url. If not found, lookup before the cursor\n * for a space character to check the url.\n *\n * On insert data: Paste a string inside a link element will edit its children\n * text but not its url.\n */\nexport const withLink: OverrideEditor<BaseLinkConfig> = ({\n  editor,\n  getOptions,\n  tf: { apply, insertBreak, insertData, insertText, normalizeNode },\n  type,\n}) => {\n  const wrapLink = () => {\n    const { getUrlHref, isUrl, rangeBeforeOptions } = getOptions();\n\n    editor.tf.withoutNormalizing(() => {\n      const selection = editor.selection!;\n\n      // get the range from first space before the cursor\n      let beforeWordRange = editor.api.range('before', selection, {\n        before: rangeBeforeOptions,\n      });\n\n      // if no space found before, get the range from block start\n      if (!beforeWordRange) {\n        beforeWordRange = editor.api.range('start', editor.selection);\n      }\n      // if no word found before the cursor, exit\n      if (!beforeWordRange) return;\n\n      const hasLink = editor.api.some({\n        at: beforeWordRange,\n        match: { type },\n      });\n\n      // if word before the cursor has a link, exit\n      if (hasLink) return;\n\n      let beforeWordText = editor.api.string(beforeWordRange);\n      beforeWordText = getUrlHref?.(beforeWordText) ?? beforeWordText;\n\n      // if word before is not an url, exit\n      if (!isUrl!(beforeWordText)) return;\n\n      // select the word to wrap link\n      editor.tf.select(beforeWordRange);\n\n      // wrap link\n      upsertLink(editor, {\n        url: beforeWordText,\n      });\n\n      // collapse selection\n      editor.tf.collapse({ edge: 'end' });\n    });\n  };\n\n  return {\n    transforms: {\n      apply(operation) {\n        if (operation.type === 'set_selection') {\n          const range = operation.newProperties as TRange | null;\n\n          if (range?.focus && range.anchor && RangeApi.isCollapsed(range)) {\n            const entry = editor.api.above({\n              at: range,\n              match: { type },\n            });\n\n            if (entry) {\n              const [, path] = entry;\n\n              let newPoint: Point | undefined;\n\n              if (editor.api.isStart(range.focus, path)) {\n                newPoint = editor.api.end(path, { previous: true });\n              }\n              if (editor.api.isEnd(range.focus, path)) {\n                newPoint = editor.api.start(path, { next: true });\n              }\n              if (newPoint) {\n                operation.newProperties = {\n                  anchor: newPoint,\n                  focus: newPoint,\n                };\n              }\n            }\n          }\n        }\n\n        apply(operation);\n      },\n\n      insertBreak() {\n        if (!editor.api.isCollapsed()) return insertBreak();\n\n        wrapLink();\n        insertBreak();\n      },\n\n      insertData(data) {\n        const { getUrlHref, keepSelectedTextOnPaste } = getOptions();\n\n        const text = data.getData('text/plain');\n        const textHref = getUrlHref?.(text);\n\n        if (text) {\n          const value = textHref || text;\n          const inserted = upsertLink(editor, {\n            insertTextInLink: true,\n            text: keepSelectedTextOnPaste ? undefined : value,\n            url: value,\n          });\n\n          if (inserted) return;\n        }\n\n        insertData(data);\n      },\n\n      insertText(text, options) {\n        if (text === ' ' && editor.api.isCollapsed()) {\n          wrapLink();\n        }\n\n        insertText(text, options);\n      },\n\n      normalizeNode([node, path]) {\n        if (node.type === type) {\n          const range = editor.selection;\n\n          if (\n            range &&\n            editor.api.isCollapsed() &&\n            editor.api.isEnd(range.focus, path)\n          ) {\n            const nextPoint = editor.api.start(path, { next: true });\n\n            // select next text node if any\n            if (nextPoint) {\n              editor.tf.select(nextPoint);\n            } else {\n              // insert text node then select\n              const nextPath = PathApi.next(path);\n              editor.tf.insertNodes({ text: '' } as any, { at: nextPath });\n              editor.tf.select(nextPath);\n            }\n          }\n        }\n\n        normalizeNode([node, path]);\n      },\n    },\n  };\n};\n","import type { InsertNodesOptions, SlateEditor, TText } from '@udecode/plate';\n\nimport type { TLinkElement } from '../types';\n\nimport { type CreateLinkNodeOptions, createLinkNode } from '../utils';\n\n/** Insert a link node. */\nexport const insertLink = (\n  editor: SlateEditor,\n  createLinkNodeOptions: CreateLinkNodeOptions,\n  options?: InsertNodesOptions\n) => {\n  editor.tf.insertNodes<TLinkElement | TText>(\n    [createLinkNode(editor, createLinkNodeOptions)],\n    options as any\n  );\n};\n","import {\n  type SlateEditor,\n  type UnwrapNodesOptions,\n  ElementApi,\n} from '@udecode/plate';\n\nimport { BaseLinkPlugin } from '../BaseLinkPlugin';\n\n/** Unwrap link node. */\nexport const unwrapLink = (\n  editor: SlateEditor,\n  options?: {\n    split?: boolean;\n  } & UnwrapNodesOptions\n) => {\n  return editor.tf.withoutNormalizing(() => {\n    if (options?.split) {\n      const linkAboveAnchor = editor.api.above({\n        at: editor.selection?.anchor,\n        match: { type: editor.getType(BaseLinkPlugin) },\n      });\n\n      // anchor in link\n      if (linkAboveAnchor) {\n        editor.tf.splitNodes({\n          at: editor.selection?.anchor,\n          match: (n) =>\n            ElementApi.isElement(n) &&\n            n.type === editor.getType(BaseLinkPlugin),\n        });\n        unwrapLink(editor, {\n          at: editor.selection?.anchor,\n        });\n\n        return true;\n      }\n\n      const linkAboveFocus = editor.api.above({\n        at: editor.selection?.focus,\n        match: { type: editor.getType(BaseLinkPlugin) },\n      });\n\n      // focus in link\n      if (linkAboveFocus) {\n        editor.tf.splitNodes({\n          at: editor.selection?.focus,\n          match: (n) =>\n            ElementApi.isElement(n) &&\n            n.type === editor.getType(BaseLinkPlugin),\n        });\n        unwrapLink(editor, {\n          at: editor.selection?.focus,\n        });\n\n        return true;\n      }\n    }\n\n    editor.tf.unwrapNodes({\n      match: { type: editor.getType(BaseLinkPlugin) },\n      ...options,\n    });\n  });\n};\n","import {\n  type InsertNodesOptions,\n  type SlateEditor,\n  type UnwrapNodesOptions,\n  type WrapNodesOptions,\n  isDefined,\n  NodeApi,\n  RangeApi,\n} from '@udecode/plate';\n\nimport type { TLinkElement } from '../types';\n\nimport { BaseLinkPlugin } from '../BaseLinkPlugin';\nimport { type CreateLinkNodeOptions, validateUrl } from '../utils';\nimport { insertLink } from './insertLink';\nimport { unwrapLink } from './unwrapLink';\nimport { upsertLinkText } from './upsertLinkText';\nimport { wrapLink } from './wrapLink';\n\nexport type UpsertLinkOptions = {\n  insertNodesOptions?: InsertNodesOptions;\n  /** If true, insert text when selection is in url. */\n  insertTextInLink?: boolean;\n  skipValidation?: boolean;\n  unwrapNodesOptions?: UnwrapNodesOptions;\n  wrapNodesOptions?: WrapNodesOptions;\n} & CreateLinkNodeOptions;\n\n/**\n * If selection in a link or is not url:\n *\n * - Insert text with url, exit If selection is expanded or `update` in a link:\n * - Remove link node, get link text Then:\n * - Insert link node\n */\nexport const upsertLink = (\n  editor: SlateEditor,\n  {\n    insertNodesOptions,\n    insertTextInLink,\n    skipValidation = false,\n    target,\n    text,\n    url,\n  }: UpsertLinkOptions\n) => {\n  const at = editor.selection;\n\n  if (!at) return;\n\n  const linkAbove = editor.api.above<TLinkElement>({\n    at,\n    match: { type: editor.getType(BaseLinkPlugin) },\n  });\n\n  // anchor and focus in link -> insert text\n  if (insertTextInLink && linkAbove) {\n    // we don't want to insert marks in links\n    editor.tf.insertText(url);\n\n    return true;\n  }\n  if (!skipValidation && !validateUrl(editor, url)) return;\n  if (isDefined(text) && text.length === 0) {\n    text = url;\n  }\n  // edit the link url and/or target\n  if (linkAbove) {\n    if (url !== linkAbove[0]?.url || target !== linkAbove[0]?.target) {\n      editor.tf.setNodes<TLinkElement>(\n        { target, url },\n        {\n          at: linkAbove[1],\n        }\n      );\n    }\n\n    upsertLinkText(editor, { target, text, url });\n\n    return true;\n  }\n\n  // selection contains at one edge edge or between the edges\n  const linkEntry = editor.api.node<TLinkElement>({\n    at,\n    match: { type: editor.getType(BaseLinkPlugin) },\n  });\n\n  const [linkNode, linkPath] = linkEntry ?? [];\n\n  let shouldReplaceText = false;\n\n  if (linkPath && text?.length) {\n    const linkText = editor.api.string(linkPath);\n\n    if (text !== linkText) {\n      shouldReplaceText = true;\n    }\n  }\n  if (RangeApi.isExpanded(at)) {\n    // anchor and focus in link\n    if (linkAbove) {\n      unwrapLink(editor, {\n        at: linkAbove[1],\n      });\n    } else {\n      unwrapLink(editor, {\n        split: true,\n      });\n    }\n\n    wrapLink(editor, {\n      target,\n      url,\n    });\n\n    upsertLinkText(editor, { target, text, url });\n\n    return true;\n  }\n  if (shouldReplaceText) {\n    editor.tf.removeNodes({\n      at: linkPath,\n    });\n  }\n\n  const props = NodeApi.extractProps(linkNode ?? ({} as any));\n\n  const path = editor.selection?.focus.path;\n\n  if (!path) return;\n\n  // link text should have the focused leaf marks\n  const leaf = NodeApi.leaf(editor, path);\n\n  // if text is empty, text is url\n  if (!text?.length) {\n    text = url;\n  }\n\n  insertLink(\n    editor,\n    {\n      ...props,\n      children: [\n        {\n          ...leaf,\n          text,\n        },\n      ],\n      target,\n      url,\n    },\n    insertNodesOptions\n  );\n\n  return true;\n};\n","import type { SlateEditor, TText } from '@udecode/plate';\n\nimport type { TLinkElement } from '../types';\nimport type { UpsertLinkOptions } from './upsertLink';\n\nimport { BaseLinkPlugin } from '../BaseLinkPlugin';\n\n/**\n * If the text is different than the link above text, replace link children by a\n * new text. The new text has the same marks than the first text replaced.\n */\nexport const upsertLinkText = (\n  editor: SlateEditor,\n  { text }: UpsertLinkOptions\n) => {\n  const newLink = editor.api.above<TLinkElement>({\n    match: { type: editor.getType(BaseLinkPlugin) },\n  });\n\n  if (newLink) {\n    const [newLinkNode, newLinkPath] = newLink;\n\n    if (text?.length && text !== editor.api.string(newLinkPath)) {\n      const firstText = newLinkNode.children[0];\n\n      // remove link children\n      editor.tf.replaceNodes<TText>(\n        { ...firstText, text },\n        {\n          at: newLinkPath,\n          children: true,\n          select: true,\n        }\n      );\n    }\n  }\n};\n","import type { SlateEditor, WrapNodesOptions } from '@udecode/plate';\n\nimport type { TLinkElement } from '../types';\n\nimport { BaseLinkPlugin } from '../BaseLinkPlugin';\n\nexport interface WrapLinkOptions extends WrapNodesOptions {\n  url: string;\n  target?: string;\n}\n\n/** Wrap a link node with split. */\nexport const wrapLink = (\n  editor: SlateEditor,\n  { target, url, ...options }: WrapLinkOptions\n) => {\n  editor.tf.wrapNodes<TLinkElement>(\n    {\n      children: [],\n      target,\n      type: editor.getType(BaseLinkPlugin),\n      url,\n    },\n    { split: true, ...options } as any\n  );\n};\n"],"mappings":"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","names":["import_plate","import_plate","isUrl","import_plate","import_plate","import_plate","wrapLink","isUrl"]}
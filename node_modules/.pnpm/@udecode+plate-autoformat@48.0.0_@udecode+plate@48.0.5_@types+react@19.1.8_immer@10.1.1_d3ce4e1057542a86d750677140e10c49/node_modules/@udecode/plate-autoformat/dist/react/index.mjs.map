{"version":3,"sources":["../../src/react/AutoformatPlugin.tsx","../../src/lib/BaseAutoformatPlugin.ts","../../src/lib/transforms/autoformatBlock.ts","../../src/lib/utils/getMatchRange.ts","../../src/lib/transforms/autoformatMark.ts","../../src/lib/utils/isPreviousCharacterEmpty.ts","../../src/lib/utils/getMatchPoints.ts","../../src/lib/transforms/autoformatText.ts","../../src/lib/withAutoformat.ts","../../src/react/onKeyDownAutoformat.ts"],"sourcesContent":["import { toPlatePlugin } from '@udecode/plate/react';\n\nimport { BaseAutoformatPlugin } from '../lib/BaseAutoformatPlugin';\nimport { onKeyDownAutoformat } from './onKeyDownAutoformat';\n\nexport const AutoformatPlugin = toPlatePlugin(BaseAutoformatPlugin, {\n  handlers: {\n    onKeyDown: onKeyDownAutoformat,\n  },\n});\n","import { type PluginConfig, createTSlatePlugin } from '@udecode/plate';\n\nimport type { AutoformatRule } from './types';\n\nimport { withAutoformat } from './withAutoformat';\n\nexport type AutoformatConfig = PluginConfig<\n  'autoformat',\n  {\n    enableUndoOnDelete?: boolean;\n    /** A list of triggering rules. */\n    rules?: AutoformatRule[];\n  }\n>;\n\n/** @see {@link withAutoformat} */\nexport const BaseAutoformatPlugin = createTSlatePlugin<AutoformatConfig>({\n  key: 'autoformat',\n  options: {\n    rules: [],\n  },\n}).overrideEditor(withAutoformat);\n","import {\n  type SlateEditor,\n  type TRange,\n  BaseParagraphPlugin,\n  ElementApi,\n} from '@udecode/plate';\nimport castArray from 'lodash/castArray.js';\n\nimport type { AutoformatBlockRule } from '../types';\n\nimport { getMatchRange } from '../utils/getMatchRange';\n\nexport interface AutoformatBlockOptions extends AutoformatBlockRule {\n  text: string;\n}\n\nexport const autoformatBlock = (\n  editor: SlateEditor,\n  {\n    allowSameTypeAbove = false,\n    format,\n    match: _match,\n    matchByRegex = false,\n    preFormat,\n    text,\n    trigger,\n    triggerAtBlockStart = true,\n    type = BaseParagraphPlugin.key,\n  }: AutoformatBlockOptions\n) => {\n  const matches = castArray(_match as string[] | string);\n\n  for (const match of matches) {\n    const { end, triggers } = getMatchRange({\n      match: { end: match, start: '' },\n      trigger,\n    });\n\n    if (!triggers.includes(text)) continue;\n\n    let matchRange: TRange | undefined;\n    let textFromBlockStart = '';\n\n    if (triggerAtBlockStart) {\n      matchRange = editor.api.range('start', editor.selection);\n\n      // Don't autoformat if there is void nodes.\n      const hasVoidNode = editor.api.some({\n        at: matchRange,\n        match: (n) => ElementApi.isElement(n) && editor.api.isVoid(n),\n      });\n\n      if (hasVoidNode) continue;\n\n      textFromBlockStart = editor.api.string(matchRange);\n\n      const isMatched = matchByRegex\n        ? !!textFromBlockStart.match(end)\n        : end === textFromBlockStart;\n\n      if (!isMatched) continue;\n    } else {\n      matchRange = editor.api.range('before', editor.selection!, {\n        before: {\n          matchByRegex,\n          matchString: end,\n        },\n      });\n\n      if (!matchRange) continue;\n\n      textFromBlockStart = editor.api.string(matchRange);\n    }\n    if (!allowSameTypeAbove) {\n      // Don't autoformat if already in a block of the same type.\n      const isBelowSameBlockType = editor.api.some({ match: { type } });\n\n      if (isBelowSameBlockType) continue;\n    }\n    // if the trigger is only 1 char there is nothing to delete, so we'd delete unrelated text\n    if (match.length > 1) {\n      editor.tf.delete({\n        at: matchRange,\n      });\n    }\n    if (preFormat) {\n      preFormat(editor);\n    }\n    if (format) {\n      format(editor, { matchString: textFromBlockStart });\n    } else {\n      editor.tf.setNodes(\n        { type },\n        {\n          match: (n) => editor.api.isBlock(n),\n        }\n      );\n    }\n\n    return true;\n  }\n\n  return false;\n};\n","import castArray from 'lodash/castArray.js';\n\nimport type { AutoformatRule, MatchRange } from '../types';\n\nexport const getMatchRange = ({\n  match,\n  trigger,\n}: {\n  match: MatchRange | string;\n  trigger: AutoformatRule['trigger'];\n}) => {\n  let start: string;\n  let end: string;\n\n  if (typeof match === 'object') {\n    start = match.start;\n    end = match.end;\n  } else {\n    start = match;\n    end = start.split('').reverse().join('');\n  }\n\n  const triggers: string[] = trigger ? castArray(trigger) : [end.slice(-1)];\n\n  end = trigger ? end : end.slice(0, -1);\n\n  return {\n    end,\n    start,\n    triggers,\n  };\n};\n","import type { Editor, TRange } from '@udecode/plate';\n\nimport castArray from 'lodash/castArray.js';\n\nimport type { AutoformatMarkRule } from '../types';\n\nimport { getMatchPoints } from '../utils/getMatchPoints';\nimport { getMatchRange } from '../utils/getMatchRange';\n\nexport interface AutoformatMarkOptions extends AutoformatMarkRule {\n  text: string;\n}\n\nexport const autoformatMark = (\n  editor: Editor,\n  { ignoreTrim, match: _match, text, trigger, type }: AutoformatMarkOptions\n) => {\n  if (!type) return false;\n\n  const selection = editor.selection!;\n  const matches = castArray(_match);\n\n  for (const match of matches) {\n    const { end, start, triggers } = getMatchRange({\n      match,\n      trigger,\n    });\n\n    if (!triggers.includes(text)) continue;\n\n    const matched = getMatchPoints(editor, { end, start });\n\n    if (!matched) continue;\n\n    const { afterStartMatchPoint, beforeEndMatchPoint, beforeStartMatchPoint } =\n      matched;\n\n    const matchRange: TRange = {\n      anchor: afterStartMatchPoint!,\n      focus: beforeEndMatchPoint,\n    };\n\n    if (!ignoreTrim) {\n      const matchText = editor.api.string(matchRange);\n\n      if (matchText.trim() !== matchText) continue;\n    }\n    // delete end match\n    if (end) {\n      editor.tf.delete({\n        at: {\n          anchor: beforeEndMatchPoint,\n          focus: selection.anchor,\n        },\n      });\n    }\n\n    const marks = castArray(type);\n\n    // add mark to the text between the matches\n    editor.tf.select(matchRange as TRange);\n    marks.forEach((mark) => {\n      editor.tf.addMark(mark, true);\n    });\n    editor.tf.collapse({ edge: 'end' });\n    editor.tf.removeMarks(marks, { shouldChange: false });\n\n    editor.tf.delete({\n      at: {\n        anchor: beforeStartMatchPoint!,\n        focus: afterStartMatchPoint!,\n      },\n    });\n\n    return true;\n  }\n\n  return false;\n};\n","import type { Editor, TLocation } from '@udecode/plate';\n\nexport const isPreviousCharacterEmpty = (editor: Editor, at: TLocation) => {\n  const range = editor.api.range('before', at);\n\n  if (range) {\n    const text = editor.api.string(range);\n\n    if (text) {\n      const noWhiteSpaceRegex = new RegExp(`\\\\S+`);\n\n      return !noWhiteSpaceRegex.exec(text);\n    }\n  }\n\n  return true;\n};\n","import type { Editor, Point } from '@udecode/plate';\n\nimport type { MatchRange } from '../types';\n\nimport { isPreviousCharacterEmpty } from './isPreviousCharacterEmpty';\n\nexport type GetMatchPointsReturnType =\n  | {\n      afterStartMatchPoint: Point | undefined;\n      beforeEndMatchPoint: Point;\n      beforeStartMatchPoint: Point | undefined;\n    }\n  | undefined;\n\nexport const getMatchPoints = (editor: Editor, { end, start }: MatchRange) => {\n  const selection = editor.selection!;\n\n  let beforeEndMatchPoint: Point | undefined = selection.anchor;\n\n  if (end) {\n    beforeEndMatchPoint = editor.api.before(selection, {\n      matchString: end,\n    });\n\n    if (!beforeEndMatchPoint) return;\n  }\n\n  let afterStartMatchPoint: Point | undefined;\n  let beforeStartMatchPoint: Point | undefined;\n\n  if (start) {\n    afterStartMatchPoint = editor.api.before(beforeEndMatchPoint, {\n      afterMatch: true,\n      matchString: start,\n      skipInvalid: true,\n    });\n\n    if (!afterStartMatchPoint) return;\n\n    beforeStartMatchPoint = editor.api.before(beforeEndMatchPoint, {\n      matchString: start,\n      skipInvalid: true,\n    });\n\n    if (!isPreviousCharacterEmpty(editor, beforeStartMatchPoint as Point))\n      return;\n  }\n\n  return {\n    afterStartMatchPoint,\n    beforeEndMatchPoint,\n    beforeStartMatchPoint,\n  };\n};\n","import type { SlateEditor } from '@udecode/plate';\n\nimport castArray from 'lodash/castArray.js';\n\nimport type { AutoformatTextRule } from '../types';\n\nimport { getMatchPoints } from '../utils/getMatchPoints';\nimport { getMatchRange } from '../utils/getMatchRange';\n\nexport interface AutoformatTextOptions extends AutoformatTextRule {\n  text: string;\n}\n\nexport const autoformatText = (\n  editor: SlateEditor,\n  { format, match: _match, text, trigger }: AutoformatTextOptions\n) => {\n  const selection = editor.selection!;\n  const matches = castArray(_match);\n\n  // dup\n  for (const match of matches) {\n    const { end, start, triggers } = getMatchRange({\n      match: Array.isArray(format)\n        ? match\n        : {\n            end: match,\n            start: '',\n          },\n      trigger,\n    });\n\n    if (!triggers.includes(text)) continue;\n\n    const matched = getMatchPoints(editor, { end, start });\n\n    if (!matched) continue;\n\n    const { afterStartMatchPoint, beforeEndMatchPoint, beforeStartMatchPoint } =\n      matched;\n\n    if (end) {\n      editor.tf.delete({\n        at: {\n          anchor: beforeEndMatchPoint,\n          focus: selection.anchor,\n        },\n      });\n    }\n    if (typeof format === 'function') {\n      format(editor, matched);\n    } else {\n      const formatEnd = Array.isArray(format) ? format[1] : format;\n      editor.tf.insertText(formatEnd);\n\n      if (beforeStartMatchPoint) {\n        const formatStart = Array.isArray(format) ? format[0] : format;\n\n        editor.tf.delete({\n          at: {\n            anchor: beforeStartMatchPoint!,\n            focus: afterStartMatchPoint!,\n          },\n        });\n\n        editor.tf.insertText(formatStart, {\n          at: beforeStartMatchPoint,\n        });\n      }\n    }\n\n    return true;\n  }\n\n  return false;\n};\n","import type { OverrideEditor } from '@udecode/plate';\n\nimport type { AutoformatConfig } from './BaseAutoformatPlugin';\n\nimport { autoformatBlock } from './transforms/autoformatBlock';\nimport { autoformatMark } from './transforms/autoformatMark';\nimport { autoformatText } from './transforms/autoformatText';\n\n/**\n * Enables support for autoformatting actions. Once a match rule is validated,\n * it does not check the following rules.\n */\nexport const withAutoformat: OverrideEditor<AutoformatConfig> = ({\n  editor,\n  getOptions,\n  tf: { insertText },\n}) => {\n  return {\n    transforms: {\n      insertText(text, options) {\n        if (!editor.api.isCollapsed()) return insertText(text, options);\n\n        for (const rule of getOptions().rules!) {\n          const { insertTrigger, mode = 'text', query } = rule;\n\n          if (query && !query(editor as any, { ...rule, text })) continue;\n\n          const autoformatter: Record<typeof mode, any> = {\n            block: autoformatBlock,\n            mark: autoformatMark,\n            text: autoformatText,\n          };\n\n          if (\n            autoformatter[mode]?.(editor, {\n              ...(rule as any),\n              text,\n            })\n          ) {\n            return insertTrigger && insertText(text);\n          }\n        }\n\n        insertText(text, options);\n      },\n    },\n  };\n};\n","import type { KeyboardHandler } from '@udecode/plate/react';\n\nimport { isHotkey, RangeApi } from '@udecode/plate';\n\nimport type { AutoformatConfig } from '../lib/BaseAutoformatPlugin';\nimport type { AutoformatRule, AutoformatTextRule } from '../lib/types';\n\nexport const onKeyDownAutoformat: KeyboardHandler<AutoformatConfig> = ({\n  editor,\n  event,\n  getOptions,\n}) => {\n  const { enableUndoOnDelete, rules } = getOptions();\n\n  if (event.defaultPrevented) return false;\n  // Abort quicky if hotKey was not pressed.\n  if (!isHotkey('backspace', { byKey: true }, event)) return false;\n  if (!rules) return false;\n  if (!enableUndoOnDelete) return false;\n\n  // Abort if selection is not collapsed i.e. we're not deleting single character.\n  const { selection } = editor;\n\n  if (!selection || !editor.api.isCollapsed()) return;\n\n  // Get start and end point of selection.\n  // For example: Text|\n  //                  ^ cursor at the moment of pressing the hotkey\n  // start, end will be equal to the location of the |\n  const [start, end] = RangeApi.edges(selection);\n\n  // Get location before the cursor.\n  // before will be a point one character before | so:\n  // Text|\n  //    ^\n  const before = editor.api.before(end, {\n    distance: 1,\n    unit: 'character',\n  });\n\n  if (!start) return false;\n  if (!before) return false;\n\n  // Abort if there doesn't exist a valid character to replace.\n  const charRange = { anchor: before, focus: start };\n\n  if (!charRange) return false;\n\n  // Text|\n  //    ^\n  // Between ^ and | is t\n  const char = editor.api.string(charRange);\n\n  if (!char) return false;\n\n  const matchers: AutoformatRule[] = [...rules].filter((rule) => {\n    const textRule = rule as AutoformatTextRule;\n\n    if (textRule) {\n      return textRule.mode === 'text' && textRule.format === char;\n    }\n\n    return false;\n  });\n\n  // abort if no matching substitution is found.\n  if (!matchers || matchers.length === 0) return false;\n\n  event.preventDefault();\n\n  // remove the shorthand character.\n  editor.tf.deleteBackward();\n\n  // put back the orignal characters. This could match to a single string or an array.\n  const rule = matchers[0] as AutoformatTextRule;\n\n  if (rule && typeof rule.match === 'string') {\n    editor.tf.insertText(rule.match);\n  } else {\n    const matchArray = rule.match as string[];\n\n    if (matchArray && matchArray.length > 0) {\n      editor.tf.insertText(matchArray[0]);\n    }\n  }\n\n  return true;\n};\n"],"mappings":"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","names":["castArray","castArray","castArray","castArray","castArray","castArray","rule"]}
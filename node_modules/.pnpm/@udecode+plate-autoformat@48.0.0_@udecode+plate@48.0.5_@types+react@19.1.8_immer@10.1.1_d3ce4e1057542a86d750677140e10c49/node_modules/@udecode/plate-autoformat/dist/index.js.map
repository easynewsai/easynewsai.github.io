{"version":3,"sources":["../src/index.ts","../src/lib/BaseAutoformatPlugin.ts","../src/lib/transforms/autoformatBlock.ts","../src/lib/utils/getMatchRange.ts","../src/lib/transforms/autoformatMark.ts","../src/lib/utils/isPreviousCharacterEmpty.ts","../src/lib/utils/getMatchPoints.ts","../src/lib/transforms/autoformatText.ts","../src/lib/withAutoformat.ts","../src/lib/rules/autoformatArrow.ts","../src/lib/rules/autoformatLegal.ts","../src/lib/rules/autoformatPunctuation.ts","../src/lib/rules/autoformatSmartQuotes.ts","../src/lib/rules/math/autoformatComparison.ts","../src/lib/rules/math/autoformatEquality.ts","../src/lib/rules/math/autoformatFraction.ts","../src/lib/rules/math/autoformatOperation.ts","../src/lib/rules/math/autoformatSubscript.ts","../src/lib/rules/math/autoformatSuperscript.ts","../src/lib/rules/math/autoformatMath.ts"],"sourcesContent":["/**\n * @file Automatically generated by barrelsby.\n */\n\nexport * from './lib/index';\n","import { type PluginConfig, createTSlatePlugin } from '@udecode/plate';\n\nimport type { AutoformatRule } from './types';\n\nimport { withAutoformat } from './withAutoformat';\n\nexport type AutoformatConfig = PluginConfig<\n  'autoformat',\n  {\n    enableUndoOnDelete?: boolean;\n    /** A list of triggering rules. */\n    rules?: AutoformatRule[];\n  }\n>;\n\n/** @see {@link withAutoformat} */\nexport const BaseAutoformatPlugin = createTSlatePlugin<AutoformatConfig>({\n  key: 'autoformat',\n  options: {\n    rules: [],\n  },\n}).overrideEditor(withAutoformat);\n","import {\n  type SlateEditor,\n  type TRange,\n  BaseParagraphPlugin,\n  ElementApi,\n} from '@udecode/plate';\nimport castArray from 'lodash/castArray.js';\n\nimport type { AutoformatBlockRule } from '../types';\n\nimport { getMatchRange } from '../utils/getMatchRange';\n\nexport interface AutoformatBlockOptions extends AutoformatBlockRule {\n  text: string;\n}\n\nexport const autoformatBlock = (\n  editor: SlateEditor,\n  {\n    allowSameTypeAbove = false,\n    format,\n    match: _match,\n    matchByRegex = false,\n    preFormat,\n    text,\n    trigger,\n    triggerAtBlockStart = true,\n    type = BaseParagraphPlugin.key,\n  }: AutoformatBlockOptions\n) => {\n  const matches = castArray(_match as string[] | string);\n\n  for (const match of matches) {\n    const { end, triggers } = getMatchRange({\n      match: { end: match, start: '' },\n      trigger,\n    });\n\n    if (!triggers.includes(text)) continue;\n\n    let matchRange: TRange | undefined;\n    let textFromBlockStart = '';\n\n    if (triggerAtBlockStart) {\n      matchRange = editor.api.range('start', editor.selection);\n\n      // Don't autoformat if there is void nodes.\n      const hasVoidNode = editor.api.some({\n        at: matchRange,\n        match: (n) => ElementApi.isElement(n) && editor.api.isVoid(n),\n      });\n\n      if (hasVoidNode) continue;\n\n      textFromBlockStart = editor.api.string(matchRange);\n\n      const isMatched = matchByRegex\n        ? !!textFromBlockStart.match(end)\n        : end === textFromBlockStart;\n\n      if (!isMatched) continue;\n    } else {\n      matchRange = editor.api.range('before', editor.selection!, {\n        before: {\n          matchByRegex,\n          matchString: end,\n        },\n      });\n\n      if (!matchRange) continue;\n\n      textFromBlockStart = editor.api.string(matchRange);\n    }\n    if (!allowSameTypeAbove) {\n      // Don't autoformat if already in a block of the same type.\n      const isBelowSameBlockType = editor.api.some({ match: { type } });\n\n      if (isBelowSameBlockType) continue;\n    }\n    // if the trigger is only 1 char there is nothing to delete, so we'd delete unrelated text\n    if (match.length > 1) {\n      editor.tf.delete({\n        at: matchRange,\n      });\n    }\n    if (preFormat) {\n      preFormat(editor);\n    }\n    if (format) {\n      format(editor, { matchString: textFromBlockStart });\n    } else {\n      editor.tf.setNodes(\n        { type },\n        {\n          match: (n) => editor.api.isBlock(n),\n        }\n      );\n    }\n\n    return true;\n  }\n\n  return false;\n};\n","import castArray from 'lodash/castArray.js';\n\nimport type { AutoformatRule, MatchRange } from '../types';\n\nexport const getMatchRange = ({\n  match,\n  trigger,\n}: {\n  match: MatchRange | string;\n  trigger: AutoformatRule['trigger'];\n}) => {\n  let start: string;\n  let end: string;\n\n  if (typeof match === 'object') {\n    start = match.start;\n    end = match.end;\n  } else {\n    start = match;\n    end = start.split('').reverse().join('');\n  }\n\n  const triggers: string[] = trigger ? castArray(trigger) : [end.slice(-1)];\n\n  end = trigger ? end : end.slice(0, -1);\n\n  return {\n    end,\n    start,\n    triggers,\n  };\n};\n","import type { Editor, TRange } from '@udecode/plate';\n\nimport castArray from 'lodash/castArray.js';\n\nimport type { AutoformatMarkRule } from '../types';\n\nimport { getMatchPoints } from '../utils/getMatchPoints';\nimport { getMatchRange } from '../utils/getMatchRange';\n\nexport interface AutoformatMarkOptions extends AutoformatMarkRule {\n  text: string;\n}\n\nexport const autoformatMark = (\n  editor: Editor,\n  { ignoreTrim, match: _match, text, trigger, type }: AutoformatMarkOptions\n) => {\n  if (!type) return false;\n\n  const selection = editor.selection!;\n  const matches = castArray(_match);\n\n  for (const match of matches) {\n    const { end, start, triggers } = getMatchRange({\n      match,\n      trigger,\n    });\n\n    if (!triggers.includes(text)) continue;\n\n    const matched = getMatchPoints(editor, { end, start });\n\n    if (!matched) continue;\n\n    const { afterStartMatchPoint, beforeEndMatchPoint, beforeStartMatchPoint } =\n      matched;\n\n    const matchRange: TRange = {\n      anchor: afterStartMatchPoint!,\n      focus: beforeEndMatchPoint,\n    };\n\n    if (!ignoreTrim) {\n      const matchText = editor.api.string(matchRange);\n\n      if (matchText.trim() !== matchText) continue;\n    }\n    // delete end match\n    if (end) {\n      editor.tf.delete({\n        at: {\n          anchor: beforeEndMatchPoint,\n          focus: selection.anchor,\n        },\n      });\n    }\n\n    const marks = castArray(type);\n\n    // add mark to the text between the matches\n    editor.tf.select(matchRange as TRange);\n    marks.forEach((mark) => {\n      editor.tf.addMark(mark, true);\n    });\n    editor.tf.collapse({ edge: 'end' });\n    editor.tf.removeMarks(marks, { shouldChange: false });\n\n    editor.tf.delete({\n      at: {\n        anchor: beforeStartMatchPoint!,\n        focus: afterStartMatchPoint!,\n      },\n    });\n\n    return true;\n  }\n\n  return false;\n};\n","import type { Editor, TLocation } from '@udecode/plate';\n\nexport const isPreviousCharacterEmpty = (editor: Editor, at: TLocation) => {\n  const range = editor.api.range('before', at);\n\n  if (range) {\n    const text = editor.api.string(range);\n\n    if (text) {\n      const noWhiteSpaceRegex = new RegExp(`\\\\S+`);\n\n      return !noWhiteSpaceRegex.exec(text);\n    }\n  }\n\n  return true;\n};\n","import type { Editor, Point } from '@udecode/plate';\n\nimport type { MatchRange } from '../types';\n\nimport { isPreviousCharacterEmpty } from './isPreviousCharacterEmpty';\n\nexport type GetMatchPointsReturnType =\n  | {\n      afterStartMatchPoint: Point | undefined;\n      beforeEndMatchPoint: Point;\n      beforeStartMatchPoint: Point | undefined;\n    }\n  | undefined;\n\nexport const getMatchPoints = (editor: Editor, { end, start }: MatchRange) => {\n  const selection = editor.selection!;\n\n  let beforeEndMatchPoint: Point | undefined = selection.anchor;\n\n  if (end) {\n    beforeEndMatchPoint = editor.api.before(selection, {\n      matchString: end,\n    });\n\n    if (!beforeEndMatchPoint) return;\n  }\n\n  let afterStartMatchPoint: Point | undefined;\n  let beforeStartMatchPoint: Point | undefined;\n\n  if (start) {\n    afterStartMatchPoint = editor.api.before(beforeEndMatchPoint, {\n      afterMatch: true,\n      matchString: start,\n      skipInvalid: true,\n    });\n\n    if (!afterStartMatchPoint) return;\n\n    beforeStartMatchPoint = editor.api.before(beforeEndMatchPoint, {\n      matchString: start,\n      skipInvalid: true,\n    });\n\n    if (!isPreviousCharacterEmpty(editor, beforeStartMatchPoint as Point))\n      return;\n  }\n\n  return {\n    afterStartMatchPoint,\n    beforeEndMatchPoint,\n    beforeStartMatchPoint,\n  };\n};\n","import type { SlateEditor } from '@udecode/plate';\n\nimport castArray from 'lodash/castArray.js';\n\nimport type { AutoformatTextRule } from '../types';\n\nimport { getMatchPoints } from '../utils/getMatchPoints';\nimport { getMatchRange } from '../utils/getMatchRange';\n\nexport interface AutoformatTextOptions extends AutoformatTextRule {\n  text: string;\n}\n\nexport const autoformatText = (\n  editor: SlateEditor,\n  { format, match: _match, text, trigger }: AutoformatTextOptions\n) => {\n  const selection = editor.selection!;\n  const matches = castArray(_match);\n\n  // dup\n  for (const match of matches) {\n    const { end, start, triggers } = getMatchRange({\n      match: Array.isArray(format)\n        ? match\n        : {\n            end: match,\n            start: '',\n          },\n      trigger,\n    });\n\n    if (!triggers.includes(text)) continue;\n\n    const matched = getMatchPoints(editor, { end, start });\n\n    if (!matched) continue;\n\n    const { afterStartMatchPoint, beforeEndMatchPoint, beforeStartMatchPoint } =\n      matched;\n\n    if (end) {\n      editor.tf.delete({\n        at: {\n          anchor: beforeEndMatchPoint,\n          focus: selection.anchor,\n        },\n      });\n    }\n    if (typeof format === 'function') {\n      format(editor, matched);\n    } else {\n      const formatEnd = Array.isArray(format) ? format[1] : format;\n      editor.tf.insertText(formatEnd);\n\n      if (beforeStartMatchPoint) {\n        const formatStart = Array.isArray(format) ? format[0] : format;\n\n        editor.tf.delete({\n          at: {\n            anchor: beforeStartMatchPoint!,\n            focus: afterStartMatchPoint!,\n          },\n        });\n\n        editor.tf.insertText(formatStart, {\n          at: beforeStartMatchPoint,\n        });\n      }\n    }\n\n    return true;\n  }\n\n  return false;\n};\n","import type { OverrideEditor } from '@udecode/plate';\n\nimport type { AutoformatConfig } from './BaseAutoformatPlugin';\n\nimport { autoformatBlock } from './transforms/autoformatBlock';\nimport { autoformatMark } from './transforms/autoformatMark';\nimport { autoformatText } from './transforms/autoformatText';\n\n/**\n * Enables support for autoformatting actions. Once a match rule is validated,\n * it does not check the following rules.\n */\nexport const withAutoformat: OverrideEditor<AutoformatConfig> = ({\n  editor,\n  getOptions,\n  tf: { insertText },\n}) => {\n  return {\n    transforms: {\n      insertText(text, options) {\n        if (!editor.api.isCollapsed()) return insertText(text, options);\n\n        for (const rule of getOptions().rules!) {\n          const { insertTrigger, mode = 'text', query } = rule;\n\n          if (query && !query(editor as any, { ...rule, text })) continue;\n\n          const autoformatter: Record<typeof mode, any> = {\n            block: autoformatBlock,\n            mark: autoformatMark,\n            text: autoformatText,\n          };\n\n          if (\n            autoformatter[mode]?.(editor, {\n              ...(rule as any),\n              text,\n            })\n          ) {\n            return insertTrigger && insertText(text);\n          }\n        }\n\n        insertText(text, options);\n      },\n    },\n  };\n};\n","import type { AutoformatRule } from '../types';\n\nexport const autoformatArrow: AutoformatRule[] = [\n  {\n    format: '→',\n    match: '->',\n    mode: 'text',\n  },\n  {\n    format: '←',\n    match: '<-',\n    mode: 'text',\n  },\n  {\n    format: '⇒',\n    match: '=>',\n    mode: 'text',\n  },\n  {\n    format: '⇐',\n    match: ['<=', '≤='],\n    mode: 'text',\n  },\n];\n","import type { AutoformatRule } from '../types';\n\nexport const autoformatLegal: AutoformatRule[] = [\n  {\n    format: '™',\n    match: ['(tm)', '(TM)'],\n    mode: 'text',\n  },\n  {\n    format: '®',\n    match: ['(r)', '(R)'],\n    mode: 'text',\n  },\n\n  {\n    format: '©',\n    match: ['(c)', '(C)'],\n    mode: 'text',\n  },\n];\n\nexport const autoformatLegalHtml: AutoformatRule[] = [\n  {\n    format: '™',\n    match: '&trade;',\n    mode: 'text',\n  },\n  {\n    format: '®',\n    match: '&reg;',\n    mode: 'text',\n  },\n  {\n    format: '©',\n    match: '&copy;',\n    mode: 'text',\n  },\n  {\n    format: '§',\n    match: '&sect;',\n    mode: 'text',\n  },\n];\n","import type { AutoformatRule } from '../types';\n\nexport const autoformatPunctuation: AutoformatRule[] = [\n  {\n    format: '\\u2014',\n    match: '--',\n    mode: 'text',\n  },\n  {\n    format: '…',\n    match: '...',\n    mode: 'text',\n  },\n  {\n    format: '»',\n    match: '>>',\n    mode: 'text',\n  },\n  {\n    format: '«',\n    match: '<<',\n    mode: 'text',\n  },\n];\n","import type { AutoformatRule } from '../types';\n\nexport const autoformatSmartQuotes: AutoformatRule[] = [\n  {\n    format: ['“', '”'],\n    match: '\"',\n    mode: 'text',\n  },\n  {\n    format: ['‘', '’'],\n    match: \"'\",\n    mode: 'text',\n  },\n];\n","import type { AutoformatRule } from '../../types';\n\nexport const autoformatComparison: AutoformatRule[] = [\n  {\n    format: '≯',\n    match: '!>',\n    mode: 'text',\n  },\n  {\n    format: '≮',\n    match: '!<',\n    mode: 'text',\n  },\n  {\n    format: '≥',\n    match: '>=',\n    mode: 'text',\n  },\n  {\n    format: '≤',\n    match: '<=',\n    mode: 'text',\n  },\n  {\n    format: '≱',\n    match: '!>=',\n    mode: 'text',\n  },\n  {\n    format: '≰',\n    match: '!<=',\n    mode: 'text',\n  },\n];\n","import type { AutoformatRule } from '../../types';\n\nexport const autoformatEquality: AutoformatRule[] = [\n  {\n    format: '≠',\n    match: '!=',\n    mode: 'text',\n  },\n  {\n    format: '≡',\n    match: '==',\n    mode: 'text',\n  },\n  {\n    format: '≢',\n    match: ['!==', '≠='],\n    mode: 'text',\n  },\n  {\n    format: '≈',\n    match: '~=',\n    mode: 'text',\n  },\n  {\n    format: '≉',\n    match: '!~=',\n    mode: 'text',\n  },\n];\n","import type { AutoformatRule } from '../../types';\n\nexport const autoformatFraction: AutoformatRule[] = [\n  {\n    format: '½',\n    match: '1/2',\n    mode: 'text',\n  },\n  {\n    format: '⅓',\n    match: '1/3',\n    mode: 'text',\n  },\n  {\n    format: '¼',\n    match: '1/4',\n    mode: 'text',\n  },\n  {\n    format: '⅕',\n    match: '1/5',\n    mode: 'text',\n  },\n  {\n    format: '⅙',\n    match: '1/6',\n    mode: 'text',\n  },\n  {\n    format: '⅐',\n    match: '1/7',\n    mode: 'text',\n  },\n  {\n    format: '⅛',\n    match: '1/8',\n    mode: 'text',\n  },\n  {\n    format: '⅑',\n    match: '1/9',\n    mode: 'text',\n  },\n  {\n    format: '⅒',\n    match: '1/10',\n    mode: 'text',\n  },\n  {\n    format: '⅔',\n    match: '2/3',\n    mode: 'text',\n  },\n  {\n    format: '⅖',\n    match: '2/5',\n    mode: 'text',\n  },\n  {\n    format: '¾',\n    match: '3/4',\n    mode: 'text',\n  },\n  {\n    format: '⅗',\n    match: '3/5',\n    mode: 'text',\n  },\n  {\n    format: '⅜',\n    match: '3/8',\n    mode: 'text',\n  },\n  {\n    format: '⅘',\n    match: '4/5',\n    mode: 'text',\n  },\n  {\n    format: '⅚',\n    match: '5/6',\n    mode: 'text',\n  },\n  {\n    format: '⅝',\n    match: '5/8',\n    mode: 'text',\n  },\n  {\n    format: '⅞',\n    match: '7/8',\n    mode: 'text',\n  },\n];\n","import type { AutoformatRule } from '../../types';\n\nexport const autoformatDivision: AutoformatRule[] = [\n  {\n    format: '÷',\n    match: '//',\n    mode: 'text',\n  },\n];\n\nexport const autoformatOperation: AutoformatRule[] = [\n  {\n    format: '±',\n    match: '+-',\n    mode: 'text',\n  },\n  {\n    format: '‰',\n    match: '%%',\n    mode: 'text',\n  },\n  {\n    format: '‱',\n    match: ['%%%', '‰%'],\n    mode: 'text',\n  },\n  ...autoformatDivision,\n];\n","import type { AutoformatRule } from '../../types';\n\nexport const autoformatSubscriptNumbers: AutoformatRule[] = [\n  {\n    format: '₀',\n    match: '~0',\n    mode: 'text',\n  },\n  {\n    format: '₁',\n    match: '~1',\n    mode: 'text',\n  },\n  {\n    format: '₂',\n    match: '~2',\n    mode: 'text',\n  },\n  {\n    format: '₃',\n    match: '~3',\n    mode: 'text',\n  },\n  {\n    format: '₄',\n    match: '~4',\n    mode: 'text',\n  },\n  {\n    format: '₅',\n    match: '~5',\n    mode: 'text',\n  },\n  {\n    format: '₆',\n    match: '~6',\n    mode: 'text',\n  },\n  {\n    format: '₇',\n    match: '~7',\n    mode: 'text',\n  },\n  {\n    format: '₈',\n    match: '~8',\n    mode: 'text',\n  },\n  {\n    format: '₉',\n    match: '~9',\n    mode: 'text',\n  },\n];\n\nexport const autoformatSubscriptSymbols: AutoformatRule[] = [\n  {\n    format: '₊',\n    match: '~+',\n    mode: 'text',\n  },\n  {\n    format: '₋',\n    match: '~-',\n    mode: 'text',\n  },\n];\n","import type { AutoformatRule } from '../../types';\n\nexport const autoformatSuperscriptNumbers: AutoformatRule[] = [\n  {\n    format: '⁰',\n    match: '^0',\n    mode: 'text',\n  },\n  {\n    format: '¹',\n    match: '^1',\n    mode: 'text',\n  },\n  {\n    format: '²',\n    match: '^2',\n    mode: 'text',\n  },\n  {\n    format: '³',\n    match: '^3',\n    mode: 'text',\n  },\n  {\n    format: '⁴',\n    match: '^4',\n    mode: 'text',\n  },\n  {\n    format: '⁵',\n    match: '^5',\n    mode: 'text',\n  },\n  {\n    format: '⁶',\n    match: '^6',\n    mode: 'text',\n  },\n  {\n    format: '⁷',\n    match: '^7',\n    mode: 'text',\n  },\n  {\n    format: '⁸',\n    match: '^8',\n    mode: 'text',\n  },\n  {\n    format: '⁹',\n    match: '^9',\n    mode: 'text',\n  },\n];\n\nexport const autoformatSuperscriptSymbols: AutoformatRule[] = [\n  {\n    format: '°',\n    match: '^o',\n    mode: 'text',\n  },\n  {\n    format: '⁺',\n    match: '^+',\n    mode: 'text',\n  },\n  {\n    format: '⁻',\n    match: '^-',\n    mode: 'text',\n  },\n];\n","import { autoformatComparison } from './autoformatComparison';\nimport { autoformatEquality } from './autoformatEquality';\nimport { autoformatFraction } from './autoformatFraction';\nimport { autoformatOperation } from './autoformatOperation';\nimport {\n  autoformatSubscriptNumbers,\n  autoformatSubscriptSymbols,\n} from './autoformatSubscript';\nimport {\n  autoformatSuperscriptNumbers,\n  autoformatSuperscriptSymbols,\n} from './autoformatSuperscript';\n\nexport const autoformatMath = [\n  ...autoformatComparison,\n  ...autoformatEquality,\n  ...autoformatOperation,\n  ...autoformatFraction,\n  ...autoformatSuperscriptSymbols,\n  ...autoformatSubscriptSymbols,\n  ...autoformatSuperscriptNumbers,\n  ...autoformatSubscriptNumbers,\n];\n"],"mappings":"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","names":["import_plate","import_castArray","castArray","castArray","import_castArray","castArray","import_castArray","castArray"]}
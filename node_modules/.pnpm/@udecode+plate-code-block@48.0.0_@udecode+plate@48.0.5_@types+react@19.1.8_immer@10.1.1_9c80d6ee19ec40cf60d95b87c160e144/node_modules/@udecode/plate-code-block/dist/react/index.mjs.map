{"version":3,"sources":["../../src/react/CodeBlockPlugin.tsx","../../src/lib/BaseCodeBlockPlugin.ts","../../src/lib/deserializer/htmlDeserializerCodeBlock.ts","../../src/lib/setCodeBlockToDecorations.ts","../../src/lib/queries/getCodeLineEntry.ts","../../src/lib/queries/getIndentDepth.ts","../../src/lib/transforms/deleteStartSpace.ts","../../src/lib/transforms/indentCodeLine.ts","../../src/lib/transforms/outdentCodeLine.ts","../../src/lib/withInsertDataCodeBlock.ts","../../src/lib/withInsertFragmentCodeBlock.ts","../../src/lib/withNormalizeCodeBlock.tsx","../../src/lib/withCodeBlock.ts","../../src/react/onKeyDownCodeBlock.ts"],"sourcesContent":["import { Key, toPlatePlugin } from '@udecode/plate/react';\n\nimport {\n  BaseCodeBlockPlugin,\n  BaseCodeLinePlugin,\n  BaseCodeSyntaxPlugin,\n} from '../lib/BaseCodeBlockPlugin';\nimport { onKeyDownCodeBlock } from './onKeyDownCodeBlock';\n\nexport const CodeSyntaxPlugin = toPlatePlugin(BaseCodeSyntaxPlugin);\n\nexport const CodeLinePlugin = toPlatePlugin(BaseCodeLinePlugin);\n\n/** Enables support for pre-formatted code blocks. */\nexport const CodeBlockPlugin = toPlatePlugin(BaseCodeBlockPlugin, {\n  handlers: {\n    onKeyDown: onKeyDownCodeBlock,\n  },\n  plugins: [CodeLinePlugin, CodeSyntaxPlugin],\n}).extend(({ editor, plugin }) => ({\n  shortcuts: {\n    toggleCodeBlock: {\n      keys: [[Key.Mod, Key.Alt, '8']],\n      preventDefault: true,\n      handler: () => {\n        editor.tf.toggleBlock(editor.getType(plugin));\n      },\n    },\n  },\n}));\n","import type { createLowlight } from 'lowlight';\n\nimport {\n  type NodeEntry,\n  type PluginConfig,\n  type TElement,\n  createSlatePlugin,\n  createTSlatePlugin,\n  HtmlPlugin,\n} from '@udecode/plate';\n\nimport type { TCodeBlockElement } from './types';\n\nimport { htmlDeserializerCodeBlock } from './deserializer/htmlDeserializerCodeBlock';\nimport {\n  CODE_LINE_TO_DECORATIONS,\n  resetCodeBlockDecorations,\n  setCodeBlockToDecorations as setCodeBlockToDecorations,\n} from './setCodeBlockToDecorations';\nimport { withCodeBlock } from './withCodeBlock';\n\nexport type CodeBlockConfig = PluginConfig<\n  'code_block',\n  {\n    /**\n     * Default language to use when no language is specified. Set to null to\n     * disable syntax highlighting by default.\n     */\n    defaultLanguage?: string | null;\n    /**\n     * Lowlight instance to use for highlighting. If not provided, syntax\n     * highlighting will be disabled.\n     */\n    lowlight?: ReturnType<typeof createLowlight> | null;\n  }\n>;\n\nexport const BaseCodeLinePlugin = createTSlatePlugin({\n  key: 'code_line',\n  node: { isElement: true },\n});\n\nexport const BaseCodeSyntaxPlugin = createSlatePlugin({\n  key: 'code_syntax',\n  node: { isLeaf: true },\n});\n\nexport const BaseCodeBlockPlugin = createTSlatePlugin<CodeBlockConfig>({\n  key: 'code_block',\n  inject: {\n    plugins: {\n      [HtmlPlugin.key]: {\n        parser: {\n          query: ({ editor }) =>\n            !editor.api.some({\n              match: { type: editor.getType(BaseCodeLinePlugin) },\n            }),\n        },\n      },\n    },\n  },\n  node: { isElement: true },\n  options: {\n    defaultLanguage: null,\n    lowlight: null,\n  },\n  parsers: { html: { deserializer: htmlDeserializerCodeBlock } },\n  plugins: [BaseCodeLinePlugin, BaseCodeSyntaxPlugin],\n  decorate: ({ editor, entry: [node, path], getOptions, type }) => {\n    if (!getOptions().lowlight) return [];\n\n    const codeLineType = editor.getType(BaseCodeLinePlugin);\n\n    // Initialize decorations for the code block, we assume code line decorate will be called next.\n    if (\n      node.type === type &&\n      !CODE_LINE_TO_DECORATIONS.get((node.children as TElement[])[0])\n    ) {\n      setCodeBlockToDecorations(editor, [node as TCodeBlockElement, path]);\n    }\n\n    if (node.type === codeLineType) {\n      return CODE_LINE_TO_DECORATIONS.get(node as TElement) || [];\n    }\n\n    return [];\n  },\n})\n  .overrideEditor(\n    ({ editor, getOptions, tf: { apply, normalizeNode }, type }) => ({\n      transforms: {\n        apply(operation) {\n          if (getOptions().lowlight && operation.type === 'set_node') {\n            const entry = editor.api.node(operation.path);\n\n            if (entry?.[0].type === type && operation.newProperties?.lang) {\n              // Clear decorations for all code lines in this block\n              resetCodeBlockDecorations(entry[0] as TCodeBlockElement);\n            }\n          }\n\n          apply(operation);\n        },\n        normalizeNode(entry, options) {\n          const [node] = entry;\n\n          // Decorate is called on selection change as well, so we prefer to only run this on code block changes.\n          if (getOptions().lowlight && node.type === type) {\n            setCodeBlockToDecorations(\n              editor,\n              entry as NodeEntry<TCodeBlockElement>\n            );\n          }\n\n          normalizeNode(entry, options);\n        },\n      },\n    })\n  )\n  .overrideEditor(withCodeBlock);\n","import type { HtmlDeserializer } from '@udecode/plate';\n\nimport {\n  BaseCodeBlockPlugin,\n  BaseCodeLinePlugin,\n} from '../BaseCodeBlockPlugin';\n\nexport const htmlDeserializerCodeBlock: HtmlDeserializer = {\n  rules: [\n    {\n      validNodeName: 'PRE',\n    },\n    {\n      validNodeName: 'P',\n      validStyle: {\n        fontFamily: 'Consolas',\n      },\n    },\n  ],\n  parse: ({ element }) => {\n    const languageSelectorText =\n      [...element.childNodes].find(\n        (node: ChildNode) => node.nodeName === 'SELECT'\n      )?.textContent || '';\n\n    const textContent =\n      element.textContent?.replace(languageSelectorText, '') || '';\n\n    let lines = textContent.split('\\n');\n\n    if (!lines?.length) {\n      lines = [textContent];\n    }\n\n    const codeLines = lines.map((line) => ({\n      children: [{ text: line }],\n      type: BaseCodeLinePlugin.key,\n    }));\n\n    return {\n      children: codeLines,\n      type: BaseCodeBlockPlugin.key,\n    };\n  },\n};\n","import {\n  type DecoratedRange,\n  type NodeEntry,\n  type SlateEditor,\n  type TElement,\n  NodeApi,\n} from '@udecode/plate';\n\nimport type { TCodeBlockElement } from './types';\n\nimport {\n  BaseCodeBlockPlugin,\n  BaseCodeSyntaxPlugin,\n} from './BaseCodeBlockPlugin';\n\n// Cache for storing decorations per code line element\nexport const CODE_LINE_TO_DECORATIONS = new WeakMap<\n  TElement,\n  DecoratedRange[]\n>();\n\n// Helper function to get highlight nodes from Lowlight result\nfunction getHighlightNodes(result: any) {\n  return result.value || result.children || [];\n}\n\n// Helper function to parse nodes from Lowlight's hast tree\nfunction parseNodes(\n  nodes: any[],\n  className: string[] = []\n): { classes: string[]; text: string }[] {\n  return nodes.flatMap((node) => {\n    const classes = [\n      ...className,\n      ...(node.properties ? node.properties.className : []),\n    ];\n    if (node.children) {\n      return parseNodes(node.children, classes);\n    }\n    return { classes, text: node.value };\n  });\n}\n\n// Helper function to normalize tokens by line\nfunction normalizeTokens(tokens: { classes: string[]; text: string }[]) {\n  const lines: { classes: string[]; content: string }[][] = [[]];\n  let currentLine = lines[0];\n\n  for (const token of tokens) {\n    const tokenLines = token.text.split('\\n');\n\n    for (let i = 0; i < tokenLines.length; i++) {\n      const content = tokenLines[i];\n\n      if (content) {\n        currentLine.push({ classes: token.classes, content });\n      }\n\n      // Create a new line unless we're on the last line\n      if (i < tokenLines.length - 1) {\n        lines.push([]);\n        currentLine = lines.at(-1) as any;\n      }\n    }\n  }\n\n  return lines;\n}\n\n// Helper function to compute decorations for a code block\nexport function codeBlockToDecorations(\n  editor: SlateEditor,\n  [block, blockPath]: NodeEntry<TCodeBlockElement>\n) {\n  const { defaultLanguage, ...options } =\n    editor.getOptions(BaseCodeBlockPlugin);\n  const lowlight = options.lowlight!;\n\n  // Get all code lines and combine their text\n  const text = block.children.map((line) => NodeApi.string(line)).join('\\n');\n  const language = block.lang;\n  const effectiveLanguage = language || defaultLanguage;\n\n  let highlighted;\n  try {\n    // Skip highlighting for plaintext or when no language is specified\n    if (!effectiveLanguage || effectiveLanguage === 'plaintext') {\n      highlighted = { value: [] }; // Empty result for plaintext\n    } else if (effectiveLanguage === 'auto') {\n      highlighted = lowlight.highlightAuto(text);\n    } else {\n      highlighted = lowlight.highlight(effectiveLanguage, text);\n    }\n  } catch (error) {\n    // Verify if language is registered, fallback to plaintext if not\n    const availableLanguages = lowlight.listLanguages();\n    const isLanguageRegistered =\n      effectiveLanguage && availableLanguages.includes(effectiveLanguage);\n    if (isLanguageRegistered) {\n      editor.api.debug.error(error, 'CODE_HIGHLIGHT');\n      highlighted = { value: [] }; // Empty result on error\n    } else {\n      editor.api.debug.warn(\n        `Language \"${effectiveLanguage}\" is not registered. Falling back to plaintext`\n      );\n      highlighted = { value: [] };\n    }\n  }\n\n  // Parse and normalize tokens\n  const tokens = parseNodes(getHighlightNodes(highlighted));\n  const normalizedTokens = normalizeTokens(tokens);\n  const blockChildren = block.children as TElement[];\n\n  // Create decorations map\n  const nodeToDecorations = new Map<TElement, DecoratedRange[]>();\n\n  // Safety check: don't process more lines than we have children\n  const numLines = Math.min(normalizedTokens.length, blockChildren.length);\n\n  // Process each line's tokens\n  for (let index = 0; index < numLines; index++) {\n    const lineTokens = normalizedTokens[index];\n    const element = blockChildren[index];\n\n    if (!nodeToDecorations.has(element)) {\n      nodeToDecorations.set(element, []);\n    }\n\n    let start = 0;\n    for (const token of lineTokens) {\n      const length = token.content.length;\n      if (!length) continue;\n\n      const end = start + length;\n\n      const decoration: DecoratedRange = {\n        anchor: {\n          offset: start,\n          path: [...blockPath, index, 0],\n        },\n        [BaseCodeSyntaxPlugin.key]: true,\n        className: token.classes.join(' '),\n        focus: {\n          offset: end,\n          path: [...blockPath, index, 0],\n        },\n      } as any;\n\n      nodeToDecorations.get(element)!.push(decoration);\n      start = end;\n    }\n  }\n\n  return nodeToDecorations;\n}\n\nexport function setCodeBlockToDecorations(\n  editor: SlateEditor,\n  [block, blockPath]: NodeEntry<TCodeBlockElement>\n) {\n  const decorations = codeBlockToDecorations(editor, [block, blockPath]);\n\n  // Update the global cache with the new decorations\n  for (const [node, decs] of decorations.entries()) {\n    CODE_LINE_TO_DECORATIONS.set(node, decs);\n  }\n}\n\nexport function resetCodeBlockDecorations(codeBlock: TCodeBlockElement) {\n  codeBlock.children.forEach((line) => {\n    CODE_LINE_TO_DECORATIONS.delete(line as TElement);\n  });\n}\n","import {\n  type ElementOf,\n  type NodeEntry,\n  type SlateEditor,\n  type TElement,\n  type TLocation,\n  ElementApi,\n} from '@udecode/plate';\n\nimport { BaseCodeLinePlugin } from '../BaseCodeBlockPlugin';\n\n/** If at (default = selection) is in ul>li>p, return li and ul node entries. */\nexport const getCodeLineEntry = <N extends ElementOf<E>, E extends SlateEditor>(\n  editor: E,\n  { at = editor.selection }: { at?: TLocation | null } = {}\n) => {\n  if (\n    at &&\n    editor.api.some({\n      at,\n      match: { type: editor.getType(BaseCodeLinePlugin) },\n    })\n  ) {\n    const selectionParent = editor.api.parent(at);\n\n    if (!selectionParent) return;\n\n    const [, parentPath] = selectionParent;\n\n    const codeLine =\n      editor.api.above<TElement>({\n        at,\n        match: { type: editor.getType(BaseCodeLinePlugin) },\n      }) || editor.api.parent<N>(parentPath);\n\n    if (!codeLine) return;\n\n    const [codeLineNode, codeLinePath] = codeLine;\n\n    if (\n      ElementApi.isElement(codeLineNode) &&\n      codeLineNode.type !== editor.getType(BaseCodeLinePlugin)\n    )\n      return;\n\n    const codeBlock = editor.api.parent<N>(codeLinePath);\n\n    if (!codeBlock) return;\n\n    return {\n      codeBlock,\n      codeLine: codeLine as NodeEntry<N>,\n    };\n  }\n};\n","import type { Editor } from '@udecode/plate';\n\nimport type { IndentCodeLineOptions } from '../transforms/indentCodeLine';\n\nexport const getIndentDepth = (\n  editor: Editor,\n  { codeLine }: IndentCodeLineOptions\n) => {\n  const [, codeLinePath] = codeLine;\n  const text = editor.api.string(codeLinePath);\n\n  return text.search(/\\S|$/);\n};\n","import type { Editor } from '@udecode/plate';\n\nimport type { OutdentCodeLineOptions } from './outdentCodeLine';\n\n/** If there is a whitespace character at the start of the code line, delete it. */\nexport const deleteStartSpace = (\n  editor: Editor,\n  { codeLine }: OutdentCodeLineOptions\n) => {\n  const [, codeLinePath] = codeLine;\n  const codeLineStart = editor.api.start(codeLinePath);\n  const codeLineEnd = codeLineStart && editor.api.after(codeLineStart);\n  const spaceRange =\n    codeLineEnd && editor.api.range(codeLineStart, codeLineEnd);\n  const spaceText = editor.api.string(spaceRange);\n\n  if (/\\s/.test(spaceText)) {\n    editor.tf.delete({ at: spaceRange });\n\n    return true;\n  }\n\n  return false;\n};\n","import type { Editor, ElementEntry } from '@udecode/plate';\n\nexport interface IndentCodeLineOptions {\n  codeBlock: ElementEntry;\n  codeLine: ElementEntry;\n  indentDepth?: number;\n}\n\n/**\n * Indent if:\n *\n * - The selection is expanded OR\n * - There are no non-whitespace characters left of the cursor Indentation = 2\n *   spaces.\n */\nexport const indentCodeLine = (\n  editor: Editor,\n  { codeLine, indentDepth = 2 }: IndentCodeLineOptions\n) => {\n  const [, codeLinePath] = codeLine;\n  const codeLineStart = editor.api.start(codeLinePath)!;\n  const indent = ' '.repeat(indentDepth);\n\n  if (!editor.api.isExpanded()) {\n    const cursor = editor.selection?.anchor;\n    const range = editor.api.range(codeLineStart, cursor);\n    const text = editor.api.string(range);\n\n    if (/\\S/.test(text)) {\n      editor.tf.insertText(indent, { at: editor.selection! });\n\n      return;\n    }\n  }\n\n  editor.tf.insertText(indent, { at: codeLineStart });\n};\n","import type { Editor, ElementEntry } from '@udecode/plate';\n\nimport { deleteStartSpace } from './deleteStartSpace';\n\nexport interface OutdentCodeLineOptions {\n  codeBlock: ElementEntry;\n  codeLine: ElementEntry;\n}\n\n/** Outdent the code line. Remove 2 whitespace characters if any. */\nexport const outdentCodeLine = (\n  editor: Editor,\n  { codeBlock, codeLine }: OutdentCodeLineOptions\n) => {\n  const deleted = deleteStartSpace(editor, { codeBlock, codeLine });\n  deleted && deleteStartSpace(editor, { codeBlock, codeLine });\n};\n","import type { OverrideEditor, TElement } from '@udecode/plate';\n\nimport { BaseCodeLinePlugin } from './BaseCodeBlockPlugin';\n\nexport const withInsertDataCodeBlock: OverrideEditor = ({\n  editor,\n  tf: { insertData },\n  type: codeBlockType,\n}) => ({\n  transforms: {\n    insertData(data) {\n      const text = data.getData('text/plain');\n      const vscodeDataString = data.getData('vscode-editor-data');\n      const codeLineType = editor.getType(BaseCodeLinePlugin);\n\n      // Handle VSCode paste with language\n      if (vscodeDataString) {\n        try {\n          const vscodeData = JSON.parse(vscodeDataString);\n          const lines = text.split('\\n');\n\n          // Check if we're in a code block\n          const [blockAbove] = editor.api.block<TElement>() ?? [];\n          const isInCodeBlock =\n            blockAbove &&\n            [codeBlockType, codeLineType].includes(blockAbove?.type);\n\n          if (isInCodeBlock) {\n            // If in code block, insert first line as text at cursor\n            if (lines[0]) {\n              editor.tf.insertText(lines[0]);\n            }\n\n            // Insert remaining lines as new code lines\n            if (lines.length > 1) {\n              const nodes = lines.slice(1).map((line) => ({\n                children: [{ text: line }],\n                type: codeLineType,\n              }));\n              editor.tf.insertNodes(nodes);\n            }\n          } else {\n            // Create new code block\n            const node = {\n              children: lines.map((line) => ({\n                children: [{ text: line }],\n                type: codeLineType,\n              })),\n              lang: vscodeData?.mode,\n              type: codeBlockType,\n            };\n\n            editor.tf.insertNodes(node, {\n              select: true,\n            });\n          }\n\n          return;\n        } catch (error) {}\n      }\n\n      // Handle plain text paste into code block only if there are line breaks\n      const [blockAbove] = editor.api.block<TElement>() ?? [];\n      if (\n        blockAbove &&\n        [codeBlockType, codeLineType].includes(blockAbove?.type) &&\n        text?.includes('\\n')\n      ) {\n        const lines = text.split('\\n');\n\n        // Insert first line as text at cursor\n        if (lines[0]) {\n          editor.tf.insertText(lines[0]);\n        }\n\n        // Insert remaining lines as new code lines\n        if (lines.length > 1) {\n          const nodes = lines.slice(1).map((line) => ({\n            children: [{ text: line }],\n            type: codeLineType,\n          }));\n          editor.tf.insertNodes(nodes);\n        }\n        return;\n      }\n\n      insertData(data);\n    },\n  },\n});\n","import { type OverrideEditor, type TElement, NodeApi } from '@udecode/plate';\n\nimport { BaseCodeLinePlugin } from './BaseCodeBlockPlugin';\n\nfunction extractCodeLinesFromCodeBlock(node: TElement) {\n  return node.children as TElement[];\n}\n\nexport const withInsertFragmentCodeBlock: OverrideEditor = ({\n  editor,\n  tf: { insertFragment },\n  type: codeBlockType,\n}) => ({\n  transforms: {\n    insertFragment(fragment) {\n      const [blockAbove] = editor.api.block<TElement>() ?? [];\n      const codeLineType = editor.getType(BaseCodeLinePlugin);\n\n      function convertNodeToCodeLine(node: TElement): TElement {\n        return {\n          children: [{ text: NodeApi.string(node) }],\n          type: codeLineType,\n        };\n      }\n\n      if (\n        blockAbove &&\n        [codeBlockType, codeLineType].includes(blockAbove?.type)\n      ) {\n        return insertFragment(\n          fragment.flatMap((node) => {\n            const element = node as TElement;\n\n            return element.type === codeBlockType\n              ? extractCodeLinesFromCodeBlock(element)\n              : convertNodeToCodeLine(element);\n          })\n        );\n      }\n\n      return insertFragment(fragment);\n    },\n  },\n});\n","import { type OverrideEditor, ElementApi, NodeApi } from '@udecode/plate';\n\nimport { BaseCodeBlockPlugin, BaseCodeLinePlugin } from './BaseCodeBlockPlugin';\n\n/** Normalize code block node to force the pre>code>div.codeline structure. */\nexport const withNormalizeCodeBlock: OverrideEditor = ({\n  editor,\n  tf: { normalizeNode },\n}) => ({\n  transforms: {\n    normalizeNode([node, path]) {\n      normalizeNode([node, path]);\n\n      if (!ElementApi.isElement(node)) {\n        return;\n      }\n\n      const codeBlockType = editor.getType(BaseCodeBlockPlugin);\n      const codeLineType = editor.getType(BaseCodeLinePlugin);\n      const isCodeBlockRoot = node.type === codeBlockType;\n\n      if (isCodeBlockRoot) {\n        // Children should all be code lines\n        const nonCodeLine = Array.from(NodeApi.children(editor, path)).find(\n          ([child]) => child.type !== codeLineType\n        );\n\n        if (nonCodeLine) {\n          editor.tf.setNodes({ type: codeLineType }, { at: nonCodeLine[1] });\n        }\n      }\n    },\n  },\n});\n","import type { OverrideEditor } from '@udecode/plate';\n\nimport type { CodeBlockConfig } from './BaseCodeBlockPlugin';\n\nimport { getCodeLineEntry, getIndentDepth } from './queries';\nimport { indentCodeLine } from './transforms';\nimport { withInsertDataCodeBlock } from './withInsertDataCodeBlock';\nimport { withInsertFragmentCodeBlock } from './withInsertFragmentCodeBlock';\nimport { withNormalizeCodeBlock } from './withNormalizeCodeBlock';\n\nexport const withCodeBlock: OverrideEditor<CodeBlockConfig> = (ctx) => {\n  const {\n    editor,\n    tf: { insertBreak },\n  } = ctx;\n\n  const insertBreakCodeBlock = () => {\n    if (!editor.selection) return;\n\n    const res = getCodeLineEntry(editor, {});\n\n    if (!res) return;\n\n    const { codeBlock, codeLine } = res;\n    const indentDepth = getIndentDepth(editor, {\n      codeBlock,\n      codeLine,\n    });\n\n    insertBreak();\n\n    indentCodeLine(editor, {\n      codeBlock,\n      codeLine,\n      indentDepth,\n    });\n\n    return true;\n  };\n\n  return {\n    transforms: {\n      insertBreak() {\n        if (insertBreakCodeBlock()) return;\n\n        insertBreak();\n      },\n      ...withInsertDataCodeBlock(ctx).transforms,\n      ...withInsertFragmentCodeBlock(ctx).transforms,\n      ...withNormalizeCodeBlock(ctx).transforms,\n    },\n  };\n};\n","import type { KeyboardHandler } from '@udecode/plate/react';\n\nimport { type TElement, Hotkeys, isHotkey } from '@udecode/plate';\n\nimport { BaseCodeLinePlugin } from '../lib';\nimport { getCodeLineEntry } from '../lib/queries/getCodeLineEntry';\nimport { indentCodeLine } from '../lib/transforms/indentCodeLine';\nimport { outdentCodeLine } from '../lib/transforms/outdentCodeLine';\n\n/**\n * - Shift+Tab: outdent code line.\n * - Tab: indent code line.\n */\nexport const onKeyDownCodeBlock: KeyboardHandler = ({ editor, event }) => {\n  if (event.defaultPrevented) return;\n\n  const isTab = Hotkeys.isTab(editor, event);\n  const isUntab = Hotkeys.isUntab(editor, event);\n\n  if (isTab || isUntab) {\n    const _codeLines = editor.api.nodes<TElement>({\n      match: { type: editor.getType(BaseCodeLinePlugin) },\n    });\n    const codeLines = Array.from(_codeLines);\n\n    if (codeLines.length > 0) {\n      event.preventDefault();\n      const [, firstLinePath] = codeLines[0];\n      const codeBlock = editor.api.parent<TElement>(firstLinePath);\n\n      if (!codeBlock) return;\n\n      editor.tf.withoutNormalizing(() => {\n        for (const codeLine of codeLines) {\n          if (isUntab) {\n            outdentCodeLine(editor, { codeBlock, codeLine });\n          }\n          // indent with tab\n          if (isTab) {\n            indentCodeLine(editor, { codeBlock, codeLine });\n          }\n        }\n      });\n    }\n  }\n  if (isHotkey('mod+a', event)) {\n    const res = getCodeLineEntry(editor, {});\n\n    if (!res) return;\n\n    const { codeBlock } = res;\n    const [, codeBlockPath] = codeBlock;\n\n    if (editor.api.isAt({ end: true }) && editor.api.isAt({ start: true }))\n      return;\n\n    // select the whole code block\n    editor.tf.select(codeBlockPath);\n\n    event.preventDefault();\n    event.stopPropagation();\n  }\n\n  // Note: rather than handling mod+enter/mod+shift+enter here, we recommend\n  // using the exit-break plugin/ If not using exit-break, follow similar logic\n  // to exit-break to add behavior to exit the code-block\n};\n"],"mappings":"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","names":["blockAbove","NodeApi","NodeApi","ElementApi","NodeApi","ElementApi","NodeApi"]}
{"version":3,"sources":["../src/index.ts","../src/lib/NormalizeTypesPlugin.ts","../src/lib/withNormalizeTypes.ts","../src/lib/RemoveEmptyNodesPlugin.ts","../src/lib/withRemoveEmptyNodes.ts"],"sourcesContent":["/**\n * @file Automatically generated by barrelsby.\n */\n\nexport * from './lib/index';\n","import {\n  type Path,\n  type PluginConfig,\n  createTSlatePlugin,\n} from '@udecode/plate';\n\nimport { withNormalizeTypes } from './withNormalizeTypes';\n\nexport type NormalizeTypesConfig = PluginConfig<\n  'normalizeTypes',\n  {\n    /**\n     * Set of rules for the types. For each rule, provide a `path` and either\n     * `strictType` or `type`. If there is no node existing at `path`: insert a\n     * node with `strictType`. If there is a node existing at `path` but its\n     * type is not `strictType` or `type`: set the node type to `strictType` or\n     * `type`.\n     */\n    rules?: Rule[];\n    onError?: (err: any) => void;\n  }\n>;\n\ninterface Rule {\n  /** Path where the rule applies */\n  path: Path;\n  /** Force the type of the node at the given path */\n  strictType?: string;\n  /** Type of the inserted node at the given path if `strictType` is not provided */\n  type?: string;\n}\n\n/** @see {@link withNormalizeTypes} */\nexport const NormalizeTypesPlugin = createTSlatePlugin<NormalizeTypesConfig>({\n  key: 'normalizeTypes',\n  options: {\n    rules: [],\n  },\n}).overrideEditor(withNormalizeTypes);\n","import {\n  type OverrideEditor,\n  type TElement,\n  ElementApi,\n  NodeApi,\n} from '@udecode/plate';\n\nimport type { NormalizeTypesConfig } from './NormalizeTypesPlugin';\n\nexport const withNormalizeTypes: OverrideEditor<NormalizeTypesConfig> = ({\n  editor,\n  getOptions,\n  tf: { normalizeNode },\n}) => ({\n  transforms: {\n    normalizeNode([currentNode, currentPath]) {\n      const { rules, onError } = getOptions();\n\n      if (currentPath.length === 0) {\n        const endCurrentNormalizationPass = rules!.some(\n          ({ path, strictType, type }) => {\n            const node = NodeApi.get<TElement>(editor, path);\n\n            if (node) {\n              if (\n                strictType &&\n                ElementApi.isElement(node) &&\n                node.type !== strictType\n              ) {\n                const { children, ...props } = editor.api.create.block({\n                  type: strictType,\n                });\n                editor.tf.setNodes(props, {\n                  at: path,\n                });\n\n                return true;\n              }\n            } else {\n              try {\n                editor.tf.insertNodes(\n                  editor.api.create.block({ type: strictType ?? type! }),\n                  { at: path }\n                );\n\n                return true;\n              } catch (error) {\n                onError?.(error);\n              }\n            }\n\n            return false;\n          }\n        );\n\n        if (endCurrentNormalizationPass) {\n          return;\n        }\n      }\n\n      return normalizeNode([currentNode, currentPath]);\n    },\n  },\n});\n","import { type PluginConfig, createTSlatePlugin } from '@udecode/plate';\n\nimport { withRemoveEmptyNodes } from './withRemoveEmptyNodes';\n\nexport type RemoveEmptyNodesConfig = PluginConfig<\n  'removeEmptyNodes',\n  {\n    types?: string[] | string;\n  }\n>;\n\n/** @see {@link withRemoveEmptyNodes} */\nexport const RemoveEmptyNodesPlugin =\n  createTSlatePlugin<RemoveEmptyNodesConfig>({\n    key: 'removeEmptyNodes',\n  }).overrideEditor(withRemoveEmptyNodes);\n","import { type OverrideEditor, ElementApi, NodeApi } from '@udecode/plate';\nimport castArray from 'lodash/castArray.js';\n\nimport type { RemoveEmptyNodesConfig } from './RemoveEmptyNodesPlugin';\n\n/** Remove nodes with empty text. */\nexport const withRemoveEmptyNodes: OverrideEditor<RemoveEmptyNodesConfig> = ({\n  editor,\n  getOptions,\n  tf: { normalizeNode },\n}) => ({\n  transforms: {\n    normalizeNode([node, path]) {\n      const types = castArray(getOptions().types ?? []);\n\n      if (\n        ElementApi.isElement(node) &&\n        node.type &&\n        types.includes(node.type) &&\n        NodeApi.string(node) === ''\n      ) {\n        editor.tf.removeNodes({ at: path });\n\n        return;\n      }\n\n      normalizeNode([node, path]);\n    },\n  },\n});\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA,IAAAA,gBAIO;;;ACJP,mBAKO;AAIA,IAAM,qBAA2D,CAAC;AAAA,EACvE;AAAA,EACA;AAAA,EACA,IAAI,EAAE,cAAc;AACtB,OAAO;AAAA,EACL,YAAY;AAAA,IACV,cAAc,CAAC,aAAa,WAAW,GAAG;AACxC,YAAM,EAAE,OAAO,QAAQ,IAAI,WAAW;AAEtC,UAAI,YAAY,WAAW,GAAG;AAC5B,cAAM,8BAA8B,MAAO;AAAA,UACzC,CAAC,EAAE,MAAM,YAAY,KAAK,MAAM;AAC9B,kBAAM,OAAO,qBAAQ,IAAc,QAAQ,IAAI;AAE/C,gBAAI,MAAM;AACR,kBACE,cACA,wBAAW,UAAU,IAAI,KACzB,KAAK,SAAS,YACd;AACA,sBAAM,EAAE,UAAU,GAAG,MAAM,IAAI,OAAO,IAAI,OAAO,MAAM;AAAA,kBACrD,MAAM;AAAA,gBACR,CAAC;AACD,uBAAO,GAAG,SAAS,OAAO;AAAA,kBACxB,IAAI;AAAA,gBACN,CAAC;AAED,uBAAO;AAAA,cACT;AAAA,YACF,OAAO;AACL,kBAAI;AACF,uBAAO,GAAG;AAAA,kBACR,OAAO,IAAI,OAAO,MAAM,EAAE,MAAM,cAAc,KAAM,CAAC;AAAA,kBACrD,EAAE,IAAI,KAAK;AAAA,gBACb;AAEA,uBAAO;AAAA,cACT,SAAS,OAAO;AACd,0BAAU,KAAK;AAAA,cACjB;AAAA,YACF;AAEA,mBAAO;AAAA,UACT;AAAA,QACF;AAEA,YAAI,6BAA6B;AAC/B;AAAA,QACF;AAAA,MACF;AAEA,aAAO,cAAc,CAAC,aAAa,WAAW,CAAC;AAAA,IACjD;AAAA,EACF;AACF;;;AD9BO,IAAM,2BAAuB,kCAAyC;AAAA,EAC3E,KAAK;AAAA,EACL,SAAS;AAAA,IACP,OAAO,CAAC;AAAA,EACV;AACF,CAAC,EAAE,eAAe,kBAAkB;;;AEtCpC,IAAAC,gBAAsD;;;ACAtD,IAAAC,gBAAyD;AACzD,uBAAsB;AAKf,IAAM,uBAA+D,CAAC;AAAA,EAC3E;AAAA,EACA;AAAA,EACA,IAAI,EAAE,cAAc;AACtB,OAAO;AAAA,EACL,YAAY;AAAA,IACV,cAAc,CAAC,MAAM,IAAI,GAAG;AAC1B,YAAM,YAAQ,iBAAAC,SAAU,WAAW,EAAE,SAAS,CAAC,CAAC;AAEhD,UACE,yBAAW,UAAU,IAAI,KACzB,KAAK,QACL,MAAM,SAAS,KAAK,IAAI,KACxB,sBAAQ,OAAO,IAAI,MAAM,IACzB;AACA,eAAO,GAAG,YAAY,EAAE,IAAI,KAAK,CAAC;AAElC;AAAA,MACF;AAEA,oBAAc,CAAC,MAAM,IAAI,CAAC;AAAA,IAC5B;AAAA,EACF;AACF;;;ADjBO,IAAM,6BACX,kCAA2C;AAAA,EACzC,KAAK;AACP,CAAC,EAAE,eAAe,oBAAoB;","names":["import_plate","import_plate","import_plate","castArray"]}
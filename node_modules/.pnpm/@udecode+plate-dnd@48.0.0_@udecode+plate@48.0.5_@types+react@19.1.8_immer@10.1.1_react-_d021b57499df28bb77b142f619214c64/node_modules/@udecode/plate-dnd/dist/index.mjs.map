{"version":3,"sources":["../src/DndPlugin.tsx","../src/components/Scroller/DndScroller.tsx","../src/components/Scroller/Scroller.tsx","../src/components/Scroller/ScrollArea.tsx","../src/components/useDraggable.ts","../src/components/useDropLine.ts","../src/hooks/useDndNode.ts","../src/hooks/useDragNode.ts","../src/hooks/useDropNode.ts","../src/transforms/onDropNode.ts","../src/utils/getHoverDirection.ts","../src/utils/getNewDirection.ts","../src/transforms/onHoverNode.ts","../src/queries/getBlocksWithId.ts","../src/transforms/focusBlockStartById.ts","../src/transforms/removeBlocksAndFocus.ts","../src/transforms/selectBlockById.ts","../src/transforms/selectBlocksBySelectionOrId.ts"],"sourcesContent":["import React from 'react';\n\nimport type { Path, PluginConfig } from '@udecode/plate';\nimport type { DropTargetMonitor } from 'react-dnd';\n\nimport { type PlateEditor, createTPlatePlugin } from '@udecode/plate/react';\n\nimport type {\n  DragItemNode,\n  DropLineDirection,\n  FileDragItemNode,\n} from './types';\n\nimport { type ScrollerProps, DndScroller } from './components/Scroller';\n\nexport const DRAG_ITEM_BLOCK = 'block';\n\nexport type DndConfig = PluginConfig<\n  'dnd',\n  {\n    draggingId?: string | null;\n    dropTarget?: {\n      id: string | null;\n      line: DropLineDirection;\n    };\n    enableScroller?: boolean;\n    isDragging?: boolean;\n    scrollerProps?: Partial<ScrollerProps>;\n    onDropFiles?: (props: {\n      id: string;\n      dragItem: FileDragItemNode;\n      editor: PlateEditor;\n      monitor: DropTargetMonitor<DragItemNode, unknown>;\n      nodeRef: any;\n      target?: Path;\n    }) => void;\n  }\n>;\n\nexport const DndPlugin = createTPlatePlugin<DndConfig>({\n  key: 'dnd',\n  handlers: {\n    onDragEnd: ({ editor, plugin }) => {\n      editor.setOption(plugin, 'isDragging', false);\n    },\n    onDragStart: ({ editor, event, plugin }) => {\n      const target = event.target as HTMLElement;\n\n      const dataTransfer = (event as React.DragEvent).dataTransfer!;\n      dataTransfer.effectAllowed = 'move';\n      dataTransfer.dropEffect = 'move';\n\n      const id = target.dataset.blockId;\n\n      if (!id) return;\n\n      editor.setOption(plugin, 'draggingId', id);\n      editor.setOption(plugin, 'isDragging', true);\n    },\n    onDrop: ({ editor, getOptions }) => {\n      const id = getOptions().draggingId;\n\n      setTimeout(() => {\n        id &&\n          editor\n            .getApi({ key: 'blockSelection' })\n            .blockSelection?.addSelectedRow?.(id);\n      }, 0);\n\n      return getOptions().isDragging;\n    },\n  },\n  options: {\n    draggingId: null,\n    dropTarget: { id: null, line: '' },\n    isDragging: false,\n  },\n}).extend(({ getOptions }) => ({\n  render: {\n    afterEditable: getOptions().enableScroller\n      ? () => <DndScroller {...getOptions()?.scrollerProps} />\n      : undefined,\n  },\n}));\n","import React from 'react';\n\nimport { usePluginOption } from '@udecode/plate/react';\n\nimport { DndPlugin } from '../../DndPlugin';\nimport { type ScrollerProps, Scroller } from './Scroller';\n\nexport function DndScroller(props: Partial<ScrollerProps>) {\n  const isDragging = usePluginOption(DndPlugin, 'isDragging');\n\n  const [show, setShow] = React.useState(false);\n\n  React.useEffect(() => {\n    if (isDragging) {\n      const timeout = setTimeout(() => {\n        setShow(true);\n      }, 100);\n\n      return () => clearTimeout(timeout);\n    }\n\n    setShow(false);\n  }, [isDragging, show]);\n\n  return <Scroller enabled={isDragging && show} {...props} />;\n}\n","import React from 'react';\n\nimport { type ScrollAreaProps, ScrollArea } from './ScrollArea';\n\nexport type ScrollerProps = Omit<ScrollAreaProps, 'placement'>;\n\n/**\n * Set up an edge scroller at the top of the page for scrolling up. One at the\n * bottom for scrolling down.\n */\nexport function Scroller(props: ScrollerProps) {\n  return (\n    <>\n      <ScrollArea placement=\"top\" {...props} />\n      <ScrollArea placement=\"bottom\" {...props} />\n    </>\n  );\n}\n","import React from 'react';\n\nimport throttle from 'lodash/throttle.js';\nimport raf from 'raf';\n\nconst getCoords = (e: any) => {\n  if (e.type === 'touchmove') {\n    return { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY };\n  }\n\n  return { x: e.clientX, y: e.clientY };\n};\n\nexport interface ScrollAreaProps {\n  placement: 'bottom' | 'top';\n  containerRef?: React.RefObject<any>;\n  enabled?: boolean;\n  height?: number;\n  minStrength?: number;\n  scrollAreaProps?: React.HTMLAttributes<HTMLDivElement>;\n  strengthMultiplier?: number;\n  zIndex?: number;\n}\n\nexport function ScrollArea({\n  containerRef,\n  enabled = true,\n  height = 100,\n  minStrength = 0.15,\n  placement,\n  scrollAreaProps,\n  strengthMultiplier = 25,\n  zIndex = 10_000,\n}: ScrollAreaProps) {\n  const ref = React.useRef<HTMLDivElement>(undefined);\n\n  const scaleYRef = React.useRef(0);\n  const frameRef = React.useRef<number | null>(null);\n\n  const direction = placement === 'top' ? -1 : 1;\n\n  // Drag a fixed, invisible box of custom height at the top, and bottom\n  // of the window. Make sure to show it only when dragging something.\n  const style: React.CSSProperties = {\n    height,\n    opacity: 0,\n    position: 'fixed',\n    width: '100%',\n    zIndex,\n    ...scrollAreaProps?.style,\n  };\n\n  if (placement === 'top') {\n    style.top = 0;\n  } else if (placement === 'bottom') {\n    style.bottom = 0;\n  }\n\n  const stopScrolling = () => {\n    scaleYRef.current = 0;\n\n    if (frameRef.current) {\n      raf.cancel(frameRef.current);\n      frameRef.current = null;\n    }\n  };\n\n  const startScrolling = () => {\n    const tick = () => {\n      const scaleY = scaleYRef.current;\n\n      // stop scrolling if there's nothing to do\n      if (strengthMultiplier === 0 || scaleY === 0) {\n        stopScrolling();\n\n        return;\n      }\n\n      const container = containerRef?.current ?? window;\n      container.scrollBy(0, scaleY * strengthMultiplier * direction);\n\n      frameRef.current = raf(tick);\n\n      // there's a bug in safari where it seems like we can't get\n      // mousemove events from a container that also emits a scroll\n      // event that same frame. So we should double the strengthMultiplier and only adjust\n      // the scroll position at 30fps\n    };\n\n    tick();\n  };\n\n  // Update scaleY every 100ms or so\n  // and start scrolling if necessary\n  const updateScrolling = throttle(\n    (e) => {\n      const container = ref.current;\n\n      if (!container) return;\n\n      const { height: h, top: y } = container.getBoundingClientRect();\n      const coords = getCoords(e);\n\n      const strength = Math.max(Math.max(coords.y - y, 0) / h, minStrength);\n\n      // calculate strength\n      scaleYRef.current = direction === -1 ? 1 - strength : strength;\n\n      // start scrolling if we need to\n      if (!frameRef.current && scaleYRef.current) {\n        startScrolling();\n      }\n    },\n    100,\n    { trailing: false }\n  );\n\n  const handleEvent = (e: any) => {\n    updateScrolling(e);\n  };\n\n  React.useEffect(() => {\n    if (!enabled) {\n      stopScrolling();\n    }\n  }, [enabled]);\n\n  if (!enabled) return null;\n\n  // Hide the element if not enabled, so it doesn't interfere with clicking things under it.\n  return (\n    <div\n      ref={ref as any}\n      // touchmove events don't seem to work across siblings, so we unfortunately\n      style={style}\n      onDragEnd={stopScrolling}\n      onDragLeave={stopScrolling}\n      onDragOver={handleEvent}\n      // would have to attach the listeners to the body\n      onTouchMove={handleEvent}\n      {...scrollAreaProps}\n    />\n  );\n}\n","import React from 'react';\n\nimport { useEditorRef } from '@udecode/plate/react';\n\nimport { type UseDndNodeOptions, DRAG_ITEM_BLOCK, useDndNode } from '..';\n\nexport type DraggableState = {\n  isDragging: boolean;\n  /** The ref of the draggable element */\n  previewRef: React.RefObject<HTMLDivElement | null>;\n  /** The ref of the draggable handle */\n  handleRef: (\n    elementOrNode:\n      | Element\n      | React.ReactElement<any>\n      | React.RefObject<any>\n      | null\n  ) => void;\n};\n\nexport const useDraggable = (props: UseDndNodeOptions): DraggableState => {\n  const {\n    orientation = 'vertical',\n    type = DRAG_ITEM_BLOCK,\n    onDropHandler,\n  } = props;\n\n  const editor = useEditorRef();\n\n  const nodeRef = React.useRef<HTMLDivElement>(null);\n\n  if (!editor.plugins.dnd) return {} as any;\n\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  const { dragRef, isDragging } = useDndNode({\n    nodeRef,\n    orientation,\n    type,\n    onDropHandler,\n    ...props,\n  });\n\n  return {\n    isDragging,\n    previewRef: nodeRef,\n    handleRef: dragRef,\n  };\n};\n","import { useElement, usePluginOptions } from '@udecode/plate/react';\n\nimport type { DropLineDirection } from '../types';\n\nimport { DndPlugin } from '../DndPlugin';\n\nexport const useDropLine = ({\n  id: idProp,\n  orientation = 'vertical',\n}: {\n  /** The id of the element to show the dropline for. */\n  id?: string;\n  orientation?: 'horizontal' | 'vertical';\n} = {}): {\n  dropLine?: DropLineDirection;\n} => {\n  const element = useElement();\n  const id = idProp || (element.id as string);\n\n  const dropLine =\n    usePluginOptions(DndPlugin, ({ dropTarget }) => {\n      if (!dropTarget) return null;\n      if (dropTarget.id !== id) return null;\n\n      return dropTarget.line;\n    }) ?? '';\n\n  if (orientation) {\n    const isHorizontalDropLine = dropLine === 'left' || dropLine === 'right';\n    const isVerticalDropLine = dropLine === 'top' || dropLine === 'bottom';\n\n    // If the orientation is vertical but we got a horizontal dropline, clear it.\n    if (\n      (orientation === 'vertical' && isHorizontalDropLine) ||\n      (orientation === 'horizontal' && isVerticalDropLine)\n    ) {\n      return {\n        dropLine: '',\n      };\n    }\n  }\n\n  return {\n    dropLine,\n  };\n};\n","import { useEffect } from 'react';\nimport { getEmptyImage, NativeTypes } from 'react-dnd-html5-backend';\n\nimport type { ConnectDragSource, DropTargetMonitor } from 'react-dnd';\n\nimport { type PlateEditor, useEditorRef } from '@udecode/plate/react';\n\nimport type { DragItemNode } from '../types';\n\nimport { DndPlugin, DRAG_ITEM_BLOCK } from '../DndPlugin';\nimport { type UseDragNodeOptions, useDragNode } from './useDragNode';\nimport { type UseDropNodeOptions, useDropNode } from './useDropNode';\n\nexport type UseDndNodeOptions = Pick<UseDropNodeOptions, 'element'> &\n  Partial<Pick<UseDropNodeOptions, 'canDropNode' | 'nodeRef'>> &\n  Partial<Pick<UseDragNodeOptions, 'type'>> & {\n    /** Options passed to the drag hook. */\n    drag?: Partial<Omit<UseDragNodeOptions, 'type'>>;\n    /** Options passed to the drop hook, excluding element, nodeRef. */\n    drop?: Partial<\n      Omit<UseDropNodeOptions, 'canDropNode' | 'element' | 'nodeRef'>\n    >;\n    /** Orientation of the drag and drop interaction. */\n    orientation?: 'horizontal' | 'vertical';\n    preview?: {\n      /** Whether to disable the preview. */\n      disable?: boolean;\n      /** The reference to the preview element. */\n      ref?: any;\n    };\n    onDropHandler?: (\n      editor: PlateEditor,\n      props: {\n        id: string;\n        dragItem: DragItemNode;\n        monitor: DropTargetMonitor<DragItemNode, unknown>;\n        nodeRef: any;\n      }\n    ) => boolean | void;\n  };\n\n/**\n * {@link useDragNode} and {@link useDropNode} hooks to drag and drop a node from\n * the editor. A default preview is used to show the node being dragged, which\n * can be customized or removed. Returns the drag ref and drop line direction.\n */\nexport const useDndNode = ({\n  canDropNode,\n  drag: dragOptions,\n  drop: dropOptions,\n  element,\n  nodeRef,\n  orientation = 'vertical',\n  preview: previewOptions = {},\n  type = DRAG_ITEM_BLOCK,\n  onDropHandler,\n}: UseDndNodeOptions): {\n  dragRef: ConnectDragSource;\n  isDragging: boolean;\n  isOver: boolean;\n} => {\n  const editor = useEditorRef();\n\n  const [{ isDragging }, dragRef, preview] = useDragNode(editor, {\n    element,\n    type,\n    ...dragOptions,\n  });\n\n  const [{ isOver }, drop] = useDropNode(editor, {\n    accept: [type, NativeTypes.FILE],\n    canDropNode,\n    element,\n    nodeRef,\n    orientation,\n    onDropHandler,\n    ...dropOptions,\n  });\n\n  if (previewOptions.disable) {\n    drop(nodeRef);\n    preview(getEmptyImage(), { captureDraggingState: true });\n  } else if (previewOptions.ref) {\n    drop(nodeRef);\n    preview(previewOptions.ref);\n  } else {\n    preview(drop(nodeRef));\n  }\n\n  useEffect(() => {\n    if (!isOver && editor.getOptions(DndPlugin).dropTarget?.id) {\n      editor.setOption(DndPlugin, 'dropTarget', { id: null, line: '' });\n    }\n  }, [isOver, editor]);\n\n  return {\n    dragRef,\n    isDragging,\n    isOver,\n  };\n};\n","import { type DragSourceHookSpec, useDrag } from 'react-dnd';\n\nimport type { TElement } from '@udecode/plate';\nimport type { PlateEditor } from '@udecode/plate/react';\n\nimport type { DragItemNode } from '../types';\n\nimport { DndPlugin } from '../DndPlugin';\n\nexport interface UseDragNodeOptions\n  extends DragSourceHookSpec<DragItemNode, unknown, { isDragging: boolean }> {\n  element: TElement;\n}\n\n/**\n * `useDrag` hook to drag a node from the editor. `item` with `id` is required.\n *\n * On drag start:\n *\n * - Set `isDragging` to true\n * - Add `dragging` class to `body`\n *\n * On drag end:\n *\n * - Set `isDragging` to false\n * - Remove `dragging` class to `body`\n *\n * Collect:\n *\n * - IsDragging: true if mouse is dragging the block\n */\nexport const useDragNode = (\n  editor: PlateEditor,\n  { element: staleElement, item, ...options }: UseDragNodeOptions\n) => {\n  const elementId = staleElement.id as string;\n  return useDrag<DragItemNode, unknown, { isDragging: boolean }>(\n    () => ({\n      collect: (monitor) => ({\n        isDragging: monitor.isDragging(),\n      }),\n      end: () => {\n        editor.setOption(DndPlugin, 'isDragging', false);\n        document.body.classList.remove('dragging');\n      },\n      item(monitor) {\n        editor.setOption(DndPlugin, 'isDragging', true);\n        document.body.classList.add('dragging');\n\n        const _item = typeof item === 'function' ? item(monitor) : item;\n        const [element] = editor.api.node<TElement>({ id: elementId, at: [] })!;\n\n        return {\n          id: elementId,\n          editorId: editor.id,\n          element,\n          ..._item,\n        };\n      },\n      ...options,\n    }),\n    [editor, elementId]\n  );\n};\n","import {\n  type DropTargetHookSpec,\n  type DropTargetMonitor,\n  useDrop,\n} from 'react-dnd';\n\nimport type { NodeEntry, TElement } from '@udecode/plate';\nimport type { PlateEditor } from '@udecode/plate/react';\n\nimport type {\n  DragItemNode,\n  ElementDragItemNode,\n  FileDragItemNode,\n} from '../types';\n\nimport { DndPlugin } from '../DndPlugin';\nimport { getDropPath, onDropNode } from '../transforms/onDropNode';\nimport { onHoverNode } from '../transforms/onHoverNode';\n\nexport type CanDropCallback = (args: {\n  dragEntry: NodeEntry<TElement>;\n  dragItem: DragItemNode;\n  dropEntry: NodeEntry<TElement>;\n  editor: PlateEditor;\n}) => boolean;\n\nexport interface UseDropNodeOptions\n  extends DropTargetHookSpec<DragItemNode, unknown, { isOver: boolean }> {\n  /** The node to which the drop line is attached. */\n  element: TElement;\n\n  /** The reference to the node being dragged. */\n  nodeRef: any;\n\n  /**\n   * Intercepts the drop handling. If `false` is returned, the default drop\n   * behavior is called after. If `true` is returned, the default behavior is\n   * not called.\n   */\n  canDropNode?: CanDropCallback;\n\n  orientation?: 'horizontal' | 'vertical';\n\n  onDropHandler?: (\n    editor: PlateEditor,\n    props: {\n      id: string;\n      dragItem: DragItemNode;\n      monitor: DropTargetMonitor<DragItemNode, unknown>;\n      nodeRef: any;\n    }\n  ) => boolean | void;\n}\n\n/**\n * `useDrop` hook to drop a node on the editor.\n *\n * On drop:\n *\n * - Get hover direction (top, bottom or undefined), return early if undefined\n * - DragPath: find node with id = dragItem.id, return early if not found\n * - Focus editor\n * - DropPath: find node with id = id, its path should be next (bottom) or\n *   previous (top)\n * - Move node from dragPath to dropPath\n *\n * On hover:\n *\n * - Get drop line direction\n * - If differs from dropLine, setDropLine is called\n *\n * Collect:\n *\n * - IsOver: true if mouse is over the block\n */\nexport const useDropNode = (\n  editor: PlateEditor,\n  {\n    canDropNode,\n    element,\n    nodeRef,\n    orientation,\n    onDropHandler,\n    ...options\n  }: UseDropNodeOptions\n) => {\n  const id = element.id as string;\n\n  return useDrop<DragItemNode, unknown, { isOver: boolean }>({\n    collect: (monitor) => ({\n      isOver: monitor.isOver({\n        shallow: true,\n      }),\n    }),\n    drop: (dragItem, monitor) => {\n      // Don't call onDropNode if this is a file drop\n\n      if (!(dragItem as ElementDragItemNode).id) {\n        const result = getDropPath(editor, {\n          canDropNode,\n          dragItem,\n          element,\n          monitor,\n          nodeRef,\n          orientation,\n        });\n\n        const onDropFiles = editor.getOptions(DndPlugin).onDropFiles;\n\n        if (!result || !onDropFiles) return;\n\n        return onDropFiles({\n          id,\n          dragItem: dragItem as FileDragItemNode,\n          editor,\n          monitor,\n          nodeRef,\n          target: result.to,\n        });\n      }\n\n      const handled =\n        !!onDropHandler &&\n        onDropHandler(editor, {\n          id,\n          dragItem,\n          monitor,\n          nodeRef,\n        });\n\n      if (handled) return;\n\n      onDropNode(editor, {\n        canDropNode,\n        dragItem: dragItem as ElementDragItemNode,\n        element,\n        monitor,\n        nodeRef,\n        orientation,\n      });\n    },\n    hover(item: DragItemNode, monitor: DropTargetMonitor) {\n      onHoverNode(editor, {\n        canDropNode,\n        dragItem: item,\n        element,\n        monitor,\n        nodeRef,\n        orientation,\n      });\n    },\n    ...options,\n  });\n};\n","import type { PlateEditor } from '@udecode/plate/react';\nimport type { DropTargetMonitor } from 'react-dnd';\n\nimport {\n  type NodeEntry,\n  type Path,\n  type TElement,\n  PathApi,\n} from '@udecode/plate';\n\nimport type { UseDropNodeOptions } from '../hooks';\nimport type { DragItemNode, ElementDragItemNode } from '../types';\n\nimport { getHoverDirection } from '../utils';\n\n/** Callback called on drag and drop a node with id. */\nexport const getDropPath = (\n  editor: PlateEditor,\n  {\n    canDropNode,\n    dragItem,\n    element,\n    monitor,\n    nodeRef,\n    orientation = 'vertical',\n  }: {\n    dragItem: DragItemNode;\n    monitor: DropTargetMonitor;\n  } & Pick<\n    UseDropNodeOptions,\n    'canDropNode' | 'element' | 'nodeRef' | 'orientation'\n  >\n) => {\n  const direction = getHoverDirection({\n    dragItem,\n    element,\n    monitor,\n    nodeRef,\n    orientation,\n  });\n\n  if (!direction) return;\n\n  let dragEntry: NodeEntry<TElement> | undefined;\n  let dropEntry: NodeEntry<TElement> | undefined;\n\n  if ('element' in dragItem) {\n    const dragPath = editor.api.findPath(dragItem.element);\n    const hoveredPath = editor.api.findPath(element);\n\n    if (!dragPath || !hoveredPath) return;\n\n    dragEntry = [dragItem.element, dragPath];\n    dropEntry = [element, hoveredPath];\n  } else {\n    dropEntry = editor.api.node<TElement>({ id: element.id as string, at: [] });\n  }\n  if (!dropEntry) return;\n  if (\n    canDropNode &&\n    dragEntry &&\n    !canDropNode({ dragEntry, dragItem, dropEntry, editor })\n  ) {\n    return;\n  }\n\n  let dropPath: Path | undefined;\n\n  // if drag from file system use [] as default path\n  const dragPath = dragEntry?.[1];\n  const hoveredPath = dropEntry[1];\n\n  // Treat 'right' like 'bottom' (after hovered)\n  // Treat 'left' like 'top' (before hovered)\n  if (dragPath && (direction === 'bottom' || direction === 'right')) {\n    // Insert after hovered node\n    dropPath = hoveredPath;\n\n    // If the dragged node is already right after hovered node, no change\n    if (PathApi.equals(dragPath, PathApi.next(dropPath))) return;\n  }\n  if (direction === 'top' || direction === 'left') {\n    // Insert before hovered node\n    dropPath = [...hoveredPath.slice(0, -1), hoveredPath.at(-1)! - 1];\n\n    // If the dragged node is already right before hovered node, no change\n    if (dragPath && PathApi.equals(dragPath, dropPath)) return;\n  }\n\n  const _dropPath = dropPath as Path;\n  const before =\n    dragPath &&\n    PathApi.isBefore(dragPath, _dropPath) &&\n    PathApi.isSibling(dragPath, _dropPath);\n  const to = before ? _dropPath : PathApi.next(_dropPath);\n\n  return { direction, dragPath, to };\n};\n\nexport const onDropNode = (\n  editor: PlateEditor,\n  {\n    canDropNode,\n    dragItem,\n    element,\n    monitor,\n    nodeRef,\n    orientation = 'vertical',\n  }: {\n    dragItem: ElementDragItemNode;\n    monitor: DropTargetMonitor;\n  } & Pick<\n    UseDropNodeOptions,\n    'canDropNode' | 'element' | 'nodeRef' | 'orientation'\n  >\n) => {\n  const result = getDropPath(editor, {\n    canDropNode,\n    dragItem,\n    element,\n    monitor,\n    nodeRef,\n    orientation,\n  });\n\n  if (!result) return;\n\n  const { dragPath, to } = result;\n\n  editor.tf.moveNodes({\n    at: dragPath,\n    to,\n  });\n};\n","import type { TElement } from '@udecode/plate';\nimport type { DropTargetMonitor, XYCoord } from 'react-dnd';\n\nimport type {\n  DragItemNode,\n  DropDirection,\n  ElementDragItemNode,\n} from '../types';\n\nexport interface GetHoverDirectionOptions {\n  dragItem: DragItemNode;\n\n  /** Hovering node. */\n  element: TElement;\n\n  monitor: DropTargetMonitor;\n\n  /** The node ref of the node being dragged. */\n  nodeRef: any;\n\n  /** The orientation of the drag operation. */\n  orientation?: 'horizontal' | 'vertical';\n}\n\n/**\n * If dragging a node A over another node B: get the direction of node A\n * relative to node B.\n */\nexport const getHoverDirection = ({\n  dragItem,\n  element,\n  monitor,\n  nodeRef,\n  orientation = 'vertical',\n}: GetHoverDirectionOptions): DropDirection => {\n  if (!nodeRef.current) return;\n  // Don't replace items with themselves\n  if (element === (dragItem as ElementDragItemNode).element) return;\n\n  // Determine rectangle on screen\n  const hoverBoundingRect = nodeRef.current?.getBoundingClientRect();\n\n  if (!hoverBoundingRect) {\n    return;\n  }\n\n  // Determine mouse position\n  const clientOffset = monitor.getClientOffset();\n\n  if (!clientOffset) {\n    return;\n  }\n  if (orientation === 'vertical') {\n    // Get vertical middle\n    const hoverMiddleY = (hoverBoundingRect.bottom - hoverBoundingRect.top) / 2;\n\n    // Get pixels to the top\n    const hoverClientY = (clientOffset as XYCoord).y - hoverBoundingRect.top;\n\n    // Only perform the move when the mouse has crossed half of the items height\n    // When dragging downwards, only move when the cursor is below 50%\n    // When dragging upwards, only move when the cursor is above 50%\n\n    // Dragging downwards\n    if (hoverClientY < hoverMiddleY) {\n      return 'top';\n    }\n    // Dragging upwards\n    if (hoverClientY >= hoverMiddleY) {\n      return 'bottom';\n    }\n  } else {\n    // Horizontal orientation for columns\n    const hoverMiddleX = (hoverBoundingRect.right - hoverBoundingRect.left) / 2;\n    const hoverClientX = (clientOffset as XYCoord).x - hoverBoundingRect.left;\n\n    return hoverClientX < hoverMiddleX ? 'left' : 'right';\n  }\n};\n","/** Get new direction if updated */\nimport type { DropLineDirection } from '../types';\n\nexport const getNewDirection = (\n  previousDir: string,\n  dir?: string\n): DropLineDirection | undefined => {\n  if (!dir && previousDir) {\n    return '';\n  }\n  if (dir === 'top' && previousDir !== 'top') {\n    return 'top';\n  }\n  if (dir === 'bottom' && previousDir !== 'bottom') {\n    return 'bottom';\n  }\n  if (dir === 'left' && previousDir !== 'left') {\n    return 'left';\n  }\n  if (dir === 'right' && previousDir !== 'right') {\n    return 'right';\n  }\n};\n","import type { PlateEditor } from '@udecode/plate/react';\nimport type { DropTargetMonitor } from 'react-dnd';\n\nimport type { UseDropNodeOptions } from '../hooks/useDropNode';\nimport type { DragItemNode } from '../types';\n\nimport { DndPlugin } from '../DndPlugin';\nimport { getDropPath } from './onDropNode';\n\n/** Callback called when dragging a node and hovering nodes. */\nexport const onHoverNode = (\n  editor: PlateEditor,\n  {\n    canDropNode,\n    dragItem,\n    element,\n    monitor,\n    nodeRef,\n    orientation = 'vertical',\n  }: {\n    dragItem: DragItemNode;\n    monitor: DropTargetMonitor;\n  } & Pick<\n    UseDropNodeOptions,\n    'canDropNode' | 'element' | 'nodeRef' | 'orientation'\n  >\n) => {\n  const { dropTarget } = editor.getOptions(DndPlugin);\n  const currentId = dropTarget?.id ?? null;\n  const currentLine = dropTarget?.line ?? '';\n\n  // Check if the drop would actually move the node.\n  const result = getDropPath(editor, {\n    canDropNode,\n    dragItem,\n    element,\n    monitor,\n    nodeRef,\n    orientation,\n  });\n\n  // If getDropPath returns undefined, it means no actual move would happen.\n  // In that case, don't show a drop target.\n  if (!result) {\n    if (currentId || currentLine) {\n      editor.setOption(DndPlugin, 'dropTarget', { id: null, line: '' });\n    }\n\n    return;\n  }\n\n  const { direction } = result;\n  const newDropTarget = { id: element.id as string, line: direction };\n\n  if (newDropTarget.id !== currentId || newDropTarget.line !== currentLine) {\n    // Only set if there's a real change\n    editor.setOption(DndPlugin, 'dropTarget', newDropTarget);\n  }\n  if (direction && editor.api.isExpanded()) {\n    editor.tf.focus();\n    editor.tf.collapse();\n  }\n};\n","import type { Editor, EditorNodesOptions, ValueOf } from '@udecode/plate';\n\n/** Get blocks with an id */\nexport const getBlocksWithId = <E extends Editor>(\n  editor: E,\n  options: EditorNodesOptions<ValueOf<E>>\n) => {\n  const _nodes = editor.api.nodes({\n    match: (n) => editor.api.isBlock(n) && !!n.id,\n    ...options,\n  });\n\n  return Array.from(_nodes);\n};\n","import type { Editor } from '@udecode/plate';\n\n/** Select the start of a block by id and focus the editor. */\nexport const focusBlockStartById = (editor: Editor, id: string) => {\n  const path = editor.api.node({ id, at: [] })?.[1];\n\n  if (!path) return;\n\n  editor.tf.select(editor.api.start(path)!);\n  editor.tf.focus();\n};\n","import type { Editor, EditorNodesOptions, ValueOf } from '@udecode/plate';\n\nimport { getBlocksWithId } from '../queries/getBlocksWithId';\n\n/** Remove blocks with an id and focus the editor. */\nexport const removeBlocksAndFocus = <E extends Editor = Editor>(\n  editor: E,\n  options: EditorNodesOptions<ValueOf<E>>\n) => {\n  const nodeEntries = getBlocksWithId(editor, options);\n\n  editor.tf.removeNodes({ at: editor.api.nodesRange(nodeEntries) });\n  editor.tf.focus();\n};\n","import type { Editor } from '@udecode/plate';\n\n/** Select the block above the selection by id and focus the editor. */\nexport const selectBlockById = (editor: Editor, id: string) => {\n  const path = editor.api.node({ id, at: [] })?.[1];\n\n  if (!path) return;\n\n  editor.tf.select(editor.api.range(path)!);\n  editor.tf.focus();\n};\n","import type { PlateEditor } from '@udecode/plate/react';\n\nimport { getBlocksWithId } from '../queries/getBlocksWithId';\nimport { selectBlockById } from './selectBlockById';\n\n/**\n * Select blocks by selection or by id. If the block with id is not selected,\n * select the block with id. Else, select the blocks above the selection.\n */\nexport const selectBlocksBySelectionOrId = (\n  editor: PlateEditor,\n  id: string\n) => {\n  if (!editor.selection) return;\n\n  const blockEntries = getBlocksWithId(editor, { at: editor.selection });\n  const isBlockSelected = blockEntries.some(\n    (blockEntry) => blockEntry[0].id === id\n  );\n\n  if (isBlockSelected) {\n    editor.tf.select(editor.api.nodesRange(blockEntries)!);\n    editor.tf.focus();\n  } else {\n    selectBlockById(editor, id);\n  }\n};\n"],"mappings":"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","names":["React","React","React","React","React","React","React","React","useEditorRef","dragPath","hoveredPath","useEditorRef"]}